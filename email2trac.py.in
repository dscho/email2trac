#!@PYTHON@
# Copyright (C) 2002
#
# This file is part of the email2trac utils
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
#
# For vi/emacs or other use tabstop=4 (vi: set ts=4)
#
"""
email2trac.py -- Email tickets to Trac.

A simple MTA filter to create Trac tickets from inbound emails.

Copyright 2005, Daniel Lundin <daniel@edgewall.com>
Copyright 2005, Edgewall Software

Authors:
  Bas van der Vlies <basv@sara.nl>
  Walter de Jong <walter@sara.nl>

The scripts reads emails from stdin and inserts directly into a Trac database.

How to use
----------
 * See https://subtrac.sara.nl/oss/email2trac/

 * Create an config file:
    [DEFAULT]                        # REQUIRED
    project      : /data/trac/test   # REQUIRED
    debug        : 1                 # OPTIONAL, if set print some DEBUG info

    [jouvin]                         # OPTIONAL project declaration, if set both fields necessary
    project      : /data/trac/jouvin # use -p|--project jouvin.  
        
 * default config file is : /etc/email2trac.conf

 * Commandline opions:
                -h,--help
                -f,--file  <configuration file>
		-n,--dry-run
                -p, --project <project name>
		-t, --ticket_prefix <name>

SVN Info:
        $Id$
"""
import os
import sys
import string
import getopt
import stat
import time
import email
import email.Iterators
import email.Header
import re
import urllib
import unicodedata
from stat import *
import mimetypes
import traceback
import logging
import logging.handlers
import UserDict


from trac import __version__ as trac_version

# Will fail where unavailable, e.g. Windows
#
try:
    import syslog 
    SYSLOG_AVAILABLE = True
except ImportError:
    SYSLOG_AVAILABLE = False

from datetime import tzinfo, timedelta, datetime
from trac import config as trac_config

# Some global variables
#
trac_default_version = '0.11'
m = None 

# A UTC class needed for trac version 0.11, added by
# tbaschak at ktc dot mb dot ca
#
class UTC(tzinfo):
	"""UTC"""
	ZERO = timedelta(0)
	HOUR = timedelta(hours=1) 
	
	def utcoffset(self, dt):
		return self.ZERO 
		
	def tzname(self, dt):
		return "UTC" 
		
	def dst(self, dt):
		return self.ZERO

class SaraDict(UserDict.UserDict):
	def __init__(self, dictin = None):
		UserDict.UserDict.__init__(self)
		self.name = None 
		
		if dictin:
			if dictin.has_key('name'):
				self.name = dictin['name']
				del dictin['name']
			self.data = dictin 
			
	def get_value(self, key):
		if self.has_key(key):
			return self[key]
		else:
			return None 
				
	def __repr__(self):
		return repr(self.data) 

	def __str__(self):
		return str(self.data) 
			
	def __getattr__(self, name):
		"""
		override the class attribute get method. Return the value
		from the Userdict
		"""
		if self.data.has_key(name):
			return self.data[name] 
		else:
			return None
			
	def __setattr__(self, name, value):
		"""
		override the class attribute set method only when the UserDict
		has set its class attribute
		"""
		if self.__dict__.has_key('data'):
			self.data[name] = value
		else:
			self.__dict__[name] = value

	def __iter__(self):
		return iter(self.data.keys())

class TicketEmailParser(object):
	env = None
	comment = '> '

	def __init__(self, env, parameters, version):
		self.env = env

		# Database connection
		#
		self.db = None

		# Save parameters
		#
		self.parameters = parameters

		# Some useful mail constants
		#
		self.email_name = None
		self.email_addr = None
		self.email_from = None
		self.author     = None
		self.id         = None
		
		self.STRIP_CONTENT_TYPES = list()

		self.VERSION = version

		self.get_config = self.env.config.get

		self.setup_log()
		self.setup_parameters()

		self.DRY_RUN = parameters['dry_run']
		self.VERBOSE = parameters['verbose']

	def setup_log(self):
		"""
		Setup loging

		Note for log format the usage of `$(...)s` instead of `%(...)s` as the latter form
        would be interpreted by the ConfigParser itself.

		"""
		if not self.parameters.log_type:
			self.parameters.log_type = 'syslog'

		if self.parameters.log_type == 'file':
			if not os.path.isabs(parameters.log_file):
				self.parameters.log_file = os.path.join(self.env.path, 'log')
			self.log_handler = logging.FileHandler()

		elif self.parameters.log_type in ('winlog', 'eventlog', 'nteventlog'):
			# Requires win32 extensions
			self.log_handler = logging.handlers.NTEventLogHandler(logid, logtype='Application')

		elif self.parameters.log_type in ('syslog', 'unix'):
			self.log_handler = logging.handlers.SysLogHandler('/dev/log')

		elif self.parameters.log_type in ('stderr'):
			self.log_handler = logging.StreamHandler(sys.stderr)

		else:
			self.log_handler = logging.handlers.BufferingHandler(0)

		if self.parameters.log_format:
			self.parameters.log_format = self.parameters.log_format.replace('$(', '%(')
		else:
			self.parameters.log_format = 'Email2trac: %(message)s'


		self.logger = logging.getLogger('email2trac')

		## Setup debug level
		#
		if not self.parameters.log_level:
			self.parameters.log_level = 'CRITICAL'
		else:
			self.parameters.log_level = self.parameters.log_level.upper()

		if self.parameters.loglevel in ['DEBUG', 'ALL']:
			self.logger.setLevel(logging.DEBUG)
		elif self.parameters.loglevel in ['INFO'] or self.parameters['verbose']:
			self.logger.setLevel(logging.INFO)
		elif self.parameters.loglevel in ['ERROR']:
			self.logger.setLevel(logging.ERROR)
		elif self.parameters.loglevel in ['CRITICAL']:
			self.logger.setLevel(logging.CRITICAL)
		else:
			self.logger.setLevel(logging.WARNING)

		self.log_formatter = logging.Formatter(self.parameters.log_format)
		self.log_handler.setFormatter(self.log_formatter) 
		self.logger.addHandler(self.log_handler)
			
		
	def setup_parameters(self):
		if self.parameters.has_key('umask'):
			os.umask(int(self.parameters['umask'], 8))

		if self.parameters.has_key('debug'):
			self.DEBUG = int(self.parameters['debug'])
		else:
			self.DEBUG = 0

		if self.parameters.has_key('mailto_link'):
			self.MAILTO = int(self.parameters['mailto_link'])
			if self.parameters.has_key('mailto_cc'):
				self.MAILTO_CC = self.parameters['mailto_cc']
			else:
				self.MAILTO_CC = ''
		else:
			self.MAILTO = 0

		if self.parameters.has_key('spam_level'):
			self.SPAM_LEVEL = int(self.parameters['spam_level'])
		else:
			self.SPAM_LEVEL = 0

		if self.parameters.has_key('spam_header'):
			self.SPAM_HEADER = self.parameters['spam_header']
		else:
			self.SPAM_HEADER = 'X-Spam-Score'

		if self.parameters.has_key('email_quote'):
			self.EMAIL_QUOTE = str(self.parameters['email_quote'])
		else:	
			self.EMAIL_QUOTE = '> '

		if self.parameters.has_key('email_header'):
			self.EMAIL_HEADER = int(self.parameters['email_header'])
		else:
			self.EMAIL_HEADER = 0

		if self.parameters.has_key('alternate_notify_template'):
			self.notify_template = str(self.parameters['alternate_notify_template'])
		else:
			self.notify_template = None

		if self.parameters.has_key('alternate_notify_template_update'):
			self.notify_template_update = str(self.parameters['alternate_notify_template_update'])
		else:
			self.notify_template_update = None

		if self.parameters.has_key('reply_all'):
			self.REPLY_ALL = int(self.parameters['reply_all'])
		else:
			self.REPLY_ALL = 0

		if self.parameters.has_key('ticket_permission_system'):
			self.TICKET_PERMISSION_SYSTEM = str(self.parameters['ticket_permission_system'])
		else:
			self.TICKET_PERMISSION_SYSTEM = None

		if self.parameters.has_key('ticket_update'):
			self.TICKET_UPDATE = int(self.parameters['ticket_update'])
		else:
			self.TICKET_UPDATE = 0

		if self.parameters.has_key('ticket_update_by_subject'):
			self.TICKET_UPDATE_BY_SUBJECT = int(self.parameters['ticket_update_by_subject'])
		else:
			self.TICKET_UPDATE_BY_SUBJECT = 0

		if self.parameters.has_key('ticket_update_by_subject_lookback'):
			self.TICKET_UPDATE_BY_SUBJECT_LOOKBACK = int(self.parameters['ticket_update_by_subject_lookback'])
		else:
			self.TICKET_UPDATE_BY_SUBJECT_LOOKBACK = 30

		if self.parameters.has_key('drop_spam'):
			self.DROP_SPAM = int(self.parameters['drop_spam'])
		else:
			self.DROP_SPAM = 0

		if self.parameters.has_key('verbatim_format'):
			self.VERBATIM_FORMAT = int(self.parameters['verbatim_format'])
		else:
			self.VERBATIM_FORMAT = 1

		if self.parameters.has_key('reflow'):
			self.REFLOW = int(self.parameters['reflow'])
		else:
			self.REFLOW = 1

		if self.parameters.has_key('drop_alternative_html_version'):
			self.DROP_ALTERNATIVE_HTML_VERSION = int(self.parameters['drop_alternative_html_version'])
		else:
			self.DROP_ALTERNATIVE_HTML_VERSION = 0

		if self.parameters.has_key('strip_signature'):
			self.STRIP_SIGNATURE = int(self.parameters['strip_signature'])
		else:
			self.STRIP_SIGNATURE = 0

		if self.parameters.has_key('strip_quotes'):
			self.STRIP_QUOTES = int(self.parameters['strip_quotes'])
		else:
			self.STRIP_QUOTES = 0

		self.properties = dict()
		if self.parameters.has_key('inline_properties'):
			self.INLINE_PROPERTIES = int(self.parameters['inline_properties'])
		else:
			self.INLINE_PROPERTIES = 0

		if self.parameters.has_key('use_textwrap'):
			self.USE_TEXTWRAP = int(self.parameters['use_textwrap'])
		else:
			self.USE_TEXTWRAP = 0

		if self.parameters.has_key('binhex'):
			self.STRIP_CONTENT_TYPES.append('application/mac-binhex40')

		if self.parameters.has_key('applesingle'):
			self.STRIP_CONTENT_TYPES.append('application/applefile')

		if self.parameters.has_key('appledouble'):
			self.STRIP_CONTENT_TYPES.append('application/applefile')

		if self.parameters.has_key('strip_content_types'):
			items = self.parameters['strip_content_types'].split(',')
			for item in items:
				self.STRIP_CONTENT_TYPES.append(item.strip())

		self.WORKFLOW = None
		if self.parameters.has_key('workflow'):
			self.WORKFLOW = self.parameters['workflow']

		# Use OS independend functions
		#
		self.TMPDIR = os.path.normcase('/tmp')
		if self.parameters.has_key('tmpdir'):
			self.TMPDIR = os.path.normcase(str(self.parameters['tmpdir']))

		if self.parameters.has_key('ignore_trac_user_settings'):
			self.IGNORE_TRAC_USER_SETTINGS = int(self.parameters['ignore_trac_user_settings'])
		else:
			self.IGNORE_TRAC_USER_SETTINGS = 0

		if self.parameters.has_key('email_triggers_workflow'):
			self.EMAIL_TRIGGERS_WORKFLOW = int(self.parameters['email_triggers_workflow'])
		else:
			self.EMAIL_TRIGGERS_WORKFLOW = 1

		if self.parameters.has_key('subject_field_separator'):
			self.SUBJECT_FIELD_SEPARATOR = self.parameters['subject_field_separator'].strip()
		else:
			self.SUBJECT_FIELD_SEPARATOR = '&'

		self.trac_smtp_from = self.get_config('notification', 'smtp_from')

		self.system = None

########## Email Header Functions ###########################################################

	def spam(self, message):
		"""
		# X-Spam-Score: *** (3.255) BAYES_50,DNS_FROM_AHBL_RHSBL,HTML_
		# Note if Spam_level then '*' are included
		"""
		spam = False
		if message.has_key(self.SPAM_HEADER):
			spam_l = string.split(message[self.SPAM_HEADER])

			try:
				number = spam_l[0].count('*')
			except IndexError, detail:
				number = 0
				
			if number >= self.SPAM_LEVEL:
				spam = True
				
		# treat virus mails as spam
		#
		elif message.has_key('X-Virus-found'):			
			spam = True

		# How to handle SPAM messages
		#
		if self.DROP_SPAM and spam:
			if self.DEBUG > 2 : 
				print 'This message is a SPAM. Automatic ticket insertion refused (SPAM level > %d' % self.SPAM_LEVEL

			return 'drop'	

		elif spam:

			return 'Spam'	

		else:

			return False

	def email_header_acl(self, keyword, header_field, default):
		"""
		This function wil check if the email address is allowed or denied
		to send mail to the ticket list
	    """	
		try:
			mail_addresses = self.parameters[keyword]

			# Check if we have an empty string
			#
			if not mail_addresses:
				return default 

		except KeyError, detail:
			if self.DEBUG > 2 :
				print 'TD: %s not defined, all messages are allowed.' %(keyword)

			return default 

		mail_addresses = string.split(mail_addresses, ',')

		for entry in mail_addresses:
			entry = entry.strip()
			TO_RE = re.compile(entry, re.VERBOSE|re.IGNORECASE)
			result =  TO_RE.search(header_field)
			if result:
				return True

		return False

	def email_header_txt(self, m):
		"""
		Display To and CC addresses in description field
		"""
		s = ''

		if m['To'] and len(m['To']) > 0:
			s = "'''To:''' %s\r\n" %(m['To'])
		if m['Cc'] and len(m['Cc']) > 0:
			s = "%s'''Cc:''' %s\r\n" % (s, m['Cc'])

		return  self.email_to_unicode(s)


	def get_sender_info(self, message):
		"""
		Get the default author name and email address from the message
		""" 

		self.email_to = self.email_to_unicode(message['to']) 
		self.to_name, self.to_email_addr = email.Utils.parseaddr (self.email_to) 

		self.email_from = self.email_to_unicode(message['from'])
		self.email_name, self.email_addr  = email.Utils.parseaddr(self.email_from)

		## Trac can not handle author's name that contains spaces
		#  and forbid the ticket email address as author field

		if self.email_addr == self.trac_smtp_from:
			if self.email_name:
				self.author = self.email_name
			else:
				self.author = "email2trac"
		else:
			self.author = self.email_addr

		if self.IGNORE_TRAC_USER_SETTINGS:
			return

		# Is this a registered user, use email address as search key:
		# result:
		#   u : login name
		#   n : Name that the user has set in the settings tab
		#   e : email address that the user has set in the settings tab 
		#
		users = [ (u,n,e) for (u, n, e) in self.env.get_known_users(self.db)
			if e and (e.lower() == self.email_addr.lower()) ]

		if len(users) == 1:
			self.email_from = users[0][0]
			self.author = users[0][0]

	def set_reply_fields(self, ticket, message):
		"""
		Set all the right fields for a new ticket
		"""
		if self.DEBUG: 
			print 'TD: set_reply_fields'

		## Only use name or email adress
		#ticket['reporter'] = self.email_from
		ticket['reporter'] = self.author


		# Put all CC-addresses in ticket CC field
		#
		if self.REPLY_ALL:

			email_cc = ''

			cc_addrs = email.Utils.getaddresses( message.get_all('cc', []) )

			if not cc_addrs:
				return

			## Build a list of forbidden CC addresses
			#
			#to_addrs = email.Utils.getaddresses( message.get_all('to', []) )
			#to_list = list()
			#for n,e in to_addrs:
			#	to_list.append(e)
				
			# Always Remove reporter email address from cc-list 
			#
			try:
				cc_addrs.remove((self.author, self.email_addr))
			except ValueError, detail:
				pass

			for name,addr in cc_addrs:
		
				## Prevent mail loop
				#
				#if addr in to_list:

				if addr == self.trac_smtp_from:
					if self.DEBUG:
						print "Skipping %s mail address for CC-field" %(addr)
					continue

				if email_cc:
					email_cc = '%s, %s' %(email_cc, addr)
				else:
					email_cc = addr

			if email_cc:
				if self.DEBUG:
					print 'TD: set_reply_fields: %s' %email_cc

				ticket['cc'] = self.email_to_unicode(email_cc)


########## DEBUG functions  ###########################################################

	def debug_body(self, message_body, tempfile=False):
		if tempfile:
			import tempfile
			body_file = tempfile.mktemp('.email2trac')
		else:
			body_file = os.path.join(self.TMPDIR, 'body.txt')

		if self.DRY_RUN:
			print 'DRY-RUN: not saving body to %s' %(body_file)
			return

		print 'TD: writing body to %s' %(body_file)
		fx = open(body_file, 'wb') 
		if not message_body:
				message_body = '(None)'

		message_body = message_body.encode('utf-8')
		#message_body = unicode(message_body, 'iso-8859-15')

		fx.write(message_body)
		fx.close()
		try:
			os.chmod(body_file,S_IRWXU|S_IRWXG|S_IRWXO)
		except OSError:
			pass

	def debug_attachments(self, message_parts):
		"""
		"""
		if self.VERBOSE:
			print "VB: debug_attachments"
		
		n = 0
		for item in message_parts:
			# Skip inline text parts
			if not isinstance(item, tuple):
				continue
				
			(original, filename, part) = item

			n = n + 1
			print 'TD: part%d: Content-Type: %s' % (n, part.get_content_type())
		
			s = 'TD: part%d: filename: %s' %(n, filename)
			self.print_unicode(s)
	
			## Forbidden chars
			#
			filename = filename.replace('\\', '_')
			filename = filename.replace('/', '_') 
	

			part_file = os.path.join(self.TMPDIR, filename)
			s = 'TD: writing part%d (%s)' % (n,part_file)
			self.print_unicode(s)

			if self.DRY_RUN:
				print 'DRY_RUN: NOT saving attachments'
				continue

			part_file = util.text.unicode_quote(part_file)

			fx = open(part_file, 'wb')
			text = part.get_payload(decode=1)

			if not text:
				text = '(None)'

			fx.write(text)
			fx.close()

			try:
				os.chmod(part_file,S_IRWXU|S_IRWXG|S_IRWXO)
			except OSError:
				pass

	def save_email_for_debug(self, message, tempfile=False):

		if tempfile:
			import tempfile
			msg_file = tempfile.mktemp('.email2trac')
		else:
			#msg_file = '/var/tmp/msg.txt' 
			msg_file = os.path.join(self.TMPDIR, 'msg.txt')

		if self.DRY_RUN:
			print 'DRY_RUN: NOT saving email message to %s' %(msg_file)
		else:
			print 'TD: saving email to %s' %(msg_file)

			fx = open(msg_file, 'wb')
			fx.write('%s' % message)
			fx.close()
			
			try:
				os.chmod(msg_file,S_IRWXU|S_IRWXG|S_IRWXO)
			except OSError:
				pass

		message_parts = self.get_message_parts(message)
		message_parts = self.unique_attachment_names(message_parts)
		body_text = self.body_text(message_parts)
		self.debug_body(body_text, True)
		self.debug_attachments(message_parts)

########## Conversion functions  ###########################################################

	def email_to_unicode(self, message_str):
		"""
		Email has 7 bit ASCII code, convert it to unicode with the charset
		that is encoded in 7-bit ASCII code and encode it as utf-8 so Trac 
		understands it.
		"""
		if self.VERBOSE:
			print "VB: email_to_unicode"

		results =  email.Header.decode_header(message_str)

		s = None
		for text,format in results:
			if format:
				try:
					temp = unicode(text, format)
				except UnicodeError, detail:
					# This always works 
					#
					temp = unicode(text, 'iso-8859-15')
				except LookupError, detail:
					#text = 'ERROR: Could not find charset: %s, please install' %format
					#temp = unicode(text, 'iso-8859-15')
					temp = message_str
				    	
			else:
				temp = string.strip(text)
				temp = unicode(text, 'iso-8859-15')

			if s:
				s = '%s %s' %(s, temp)
			else:
				s = '%s' %temp

		#s = s.encode('utf-8')
		return s

	def str_to_dict(self, s):
		"""
		Transfrom a string of the form [<key>=<value>]+ to dict[<key>] = <value>
		""" 
		if self.VERBOSE:
			print "VB: str_to_dict"

		fields = string.split(s, self.SUBJECT_FIELD_SEPARATOR)

		result = dict()
		for field in fields:
			try: 
				index, value = string.split(field, '=')

				# We can not change the description of a ticket via the subject
				# line. The description is the body of the email
				#
				if index.lower() in ['description']:
					continue

				if value:
					result[index.lower()] = value

			except ValueError:
				pass
		return result

	def print_unicode(self,s):
		"""
		This function prints unicode strings uif possible else it will quote it
		"""
		try:
			print s
		except UnicodeEncodeError, detail:
			print util.text.unicode_quote(s)

########## TRAC ticket functions  ###########################################################

	def check_permission_participants(self, tkt):
		"""
		Check if the mailer is allowed to update the ticket
		"""

		if tkt['reporter'].lower() in [self.author, self.email_addr]:
			if self.DEBUG:
				print 'ALLOW, %s is the ticket reporter' %(self.email_addr)
			return True

		perm = PermissionSystem(self.env)
		if perm.check_permission('TICKET_MODIFY', self.author):
			if self.DEBUG:
				print 'ALLOW, %s has trac permission to update the ticket' %(self.author)
			return True
		else:
			return False
		

		# Is the updater in the CC?
		try:
			cc_list = tkt['cc'].split(',')
			for cc in cc_list:
				if self.email_addr.lower() in cc.strip():

					if self.DEBUG:
						print 'ALLOW, %s is in the CC' %(self.email_addr)

					return True

		except KeyError:
			return False

	def check_permission(self, tkt, action):
		"""
		check if the reporter has the right permission for the action: 
          - TICKET_CREATE
          - TICKET_MODIFY

		There are three models:
  			- None      : no checking at all
			- trac      : check the permission via trac permission model
			- email2trac: ....
		"""
		if self.VERBOSE:
			print "VB: check_permission"

		if self.TICKET_PERMISSION_SYSTEM in ['trac']:

			perm = PermissionSystem(self.env)
			if perm.check_permission(action, self.author):
				return True
			else:
				return False

		elif self.TICKET_PERMISSION_SYSTEM in ['update_restricted_to_participants']:
			if action in ['TICKET_MODIFY']:
				return (self.check_permission_participants(tkt))	
			else:
				return True

		# Default is to allow everybody ticket updates and ticket creation
		else:
				return True


	def update_ticket_fields(self, ticket, user_dict, use_default=None): 
		"""
		This will update the ticket fields. It will check if the 
		given fields are known and if the right values are specified
		It will only update the ticket field value:
			- If the field is known
			- If the value supplied is valid for the ticket field.
			  If not then there are two options:
			   1) Skip the value (use_default=None)
			   2) Set default value for field (use_default=1)
		"""
		if self.VERBOSE:
			print "VB: update_ticket_fields"

		# Build a system dictionary from the ticket fields 
		# with field as index and option as value
		#
		sys_dict = dict()
		for field in ticket.fields:
			try:
				sys_dict[field['name']] = field['options']

			except KeyError:
				sys_dict[field['name']] = None
				pass

		## Check user supplied fields an compare them with the
		# system one's
		#
		for field,value in user_dict.items():
			if self.DEBUG >= 10: 
				s = 'TD: user_field\t %s = %s' %(field,value) 
				self.print_unicode(s)

			## To prevent mail loop
			#
			if field == 'cc': 

				cc_list = user_dict['cc'].split(',')

				if self.trac_smtp_from in cc_list:
					if self.DEBUG > 10:
						print 'TD: MAIL LOOP: %s is not allowed as CC address' %(self.trac_smtp_from)
					cc_list.remove(self.trac_smtp_from)

				value = ','.join(cc_list)
				

			if sys_dict.has_key(field):

				# Check if value is an allowed system option, if TypeError then
				# every value is allowed
				#
				try:
					if value in sys_dict[field]:
						ticket[field] = value
					else:
						# Must we set a default if value is not allowed
						#
						if use_default:
							value = self.get_config('ticket', 'default_%s' %(field) )

				except TypeError:
					pass

				## Only set if we have a value
				#
				if value:
					ticket[field] = value

				if self.DEBUG >= 10: 
					s = 'ticket_field\t %s = %s' %(field,  ticket[field]) 
					self.print_unicode(s)

	def ticket_update(self, m, id, spam):
		"""
		If the current email is a reply to an existing ticket, this function
		will append the contents of this email to that ticket, instead of 
		creating a new one.
		"""
		if self.VERBOSE:
			print "VB: ticket_update: %s" %id

		# Must we update ticket fields
		#
		update_fields = dict()
		try:
			id, keywords = string.split(id, '?')

			update_fields = self.str_to_dict(keywords)

			# Strip '#' 
			#
			self.id = int(id[1:])

		except ValueError:

			# Strip '#' 
			#
			self.id = int(id[1:])

		if self.VERBOSE:
			print "VB: ticket_update: %s" %id


		# When is the change committed
		# 
		if self.VERSION < 0.11:
			when = int(time.time())
		else:
			utc = UTC()
			when = datetime.now(utc)

		try:
			tkt = Ticket(self.env, self.id, self.db)

		except util.TracError, detail:

			# Not a valid ticket

			self.id = None
			return False

		# Check the permission of the reporter
		#
		if self.TICKET_PERMISSION_SYSTEM:
			if not self.check_permission(tkt, 'TICKET_MODIFY'):
				print 'Reporter: %s has no permission to modify tickets' %self.author
				return False

		# How many changes has this ticket
		cnum = len(tkt.get_changelog())


		# reopen the ticket if it is was closed
		# We must use the ticket workflow framework
		#
		if tkt['status'] in ['closed'] and self.EMAIL_TRIGGERS_WORKFLOW:

			#print controller.actions['reopen']
			#
			# As reference	
			# req = Mock(href=Href('/'), abs_href=Href('http://www.example.com/'), authname='anonymous', perm=MockPerm(), args={})
			#
			#a = controller.render_ticket_action_control(req, tkt, 'reopen')
			#print 'controller : ', a
			#
			#b = controller.get_all_status()
			#print 'get all status: ', b
			#
			#b = controller.get_ticket_changes(req, tkt, 'reopen')
			#print 'get_ticket_changes :', b

			if self.WORKFLOW and (self.VERSION >= 0.11 ) :
				from trac.ticket.default_workflow import ConfigurableTicketWorkflow
				from trac.test import Mock, MockPerm

				req = Mock(authname='anonymous', perm=MockPerm(), args={})

				controller = ConfigurableTicketWorkflow(self.env)
				fields = controller.get_ticket_changes(req, tkt, self.WORKFLOW)

				if self.DEBUG:
					print 'TD: Workflow ticket update fields: ', fields

				for key in fields.keys():
					tkt[key] = fields[key]

			else:
				tkt['status'] = 'reopened'
				tkt['resolution'] = ''

		# Must we update some ticket fields properties via subjectline
		#
		if update_fields:
			self.update_ticket_fields(tkt, update_fields)

		message_parts = self.get_message_parts(m)
		message_parts = self.unique_attachment_names(message_parts)

		# Must we update some ticket fields properties via body_text
		#
		if self.properties:
				self.update_ticket_fields(tkt, self.properties)

		if self.EMAIL_HEADER:
			message_parts.insert(0, self.email_header_txt(m))

		body_text = self.body_text(message_parts)

		error_with_attachments = self.attach_attachments(message_parts)

		if body_text.strip() or update_fields or self.properties: 
			if self.DRY_RUN:
				print 'DRY_RUN: tkt.save_changes(self.author, body_text, ticket_change_number) ', self.author, cnum
			else:
				if error_with_attachments:
					body_text = '%s\\%s' %(error_with_attachments, body_text)
				
				tkt.save_changes(self.author, body_text, when, None, str(cnum))
			

		if not spam:
			self.notify(tkt, False, when)

		return True

	def set_ticket_fields(self, ticket):
		"""
		set the ticket fields to value specified
			- /etc/email2trac.conf with <prefix>_<field>
			- trac default values, trac.ini
		"""
		user_dict = dict()

		for field in ticket.fields:

			name = field['name'] 

			## default trac value
			#
			if not field.get('custom'):
				value = self.get_config('ticket', 'default_%s' %(name) )
			else:
				##  Else we get the default value for reporter
				#
				value = field.get('value')
				options = field.get('options')

				if value and options and (value not in options):
					 value = options[int(value)]
	
			if self.DEBUG > 10:
				s = 'TD: trac.ini name %s = %s' %(name, value)
				self.print_unicode(s)

			## email2trac.conf settings
			#
			prefix = self.parameters['ticket_prefix']
			try:
				value = self.parameters['%s_%s' %(prefix, name)]
				if self.DEBUG > 10:
					s = 'TD: email2trac.conf %s = %s ' %(name, value)
					self.print_unicode(s)

			except KeyError, detail:
				pass
		
			if self.DEBUG:
				s = 'TD: user_dict[%s] = %s' %(name, value)
				self.print_unicode(s)

			if value:
				user_dict[name] = value

		self.update_ticket_fields(ticket, user_dict, use_default=1)

		if 'status' not in user_dict.keys():
			ticket['status'] = 'new'


	def ticket_update_by_subject(self, subject):
		"""
		This list of Re: prefixes is probably incomplete. Taken from
		wikipedia. Here is how the subject is matched
		  - Re: <subject> 
		  - Re: (<Mail list label>:)+ <subject>

		So we must have the last column
		"""
		if self.VERBOSE:
			print "VB: ticket_update_by_subject()"

		matched_id = None
		if self.TICKET_UPDATE and self.TICKET_UPDATE_BY_SUBJECT:
				
			SUBJECT_RE = re.compile(r'^(RE|AW|VS|SV):(.*:)*\s*(.*)', re.IGNORECASE)
			result = SUBJECT_RE.search(subject)

			if result:
				# This is a reply
				orig_subject = result.group(3)

				if self.DEBUG:
					print 'TD: subject search string: %s' %(orig_subject)

				cursor = self.db.cursor()
				summaries = [orig_subject, '%%: %s' % orig_subject]

				##
				# Convert days to seconds
				lookback = int(time.mktime(time.gmtime())) - \
						self.TICKET_UPDATE_BY_SUBJECT_LOOKBACK * 24 * 3600


				for summary in summaries:
					if self.DEBUG:
						print 'TD: Looking for summary matching: "%s"' % summary
					sql = """SELECT id FROM ticket
						 	WHERE changetime >= %s AND summary LIKE %s
							ORDER BY changetime DESC"""
					cursor.execute(sql, [lookback, summary.strip()])

					for row in cursor:
						(matched_id,) = row
						if self.DEBUG:
							print 'TD: Found matching ticket id: %d' % matched_id
						break

					if matched_id:
						matched_id = '#%d' % matched_id
						return matched_id

		return matched_id


	def new_ticket(self, msg, subject, spam, set_fields = None):
		"""
		Create a new ticket
		"""
		if self.VERBOSE:
			print "VB: function new_ticket()"

		tkt = Ticket(self.env)

		self.set_reply_fields(tkt, msg)

		self.set_ticket_fields(tkt)

		# Check the permission of the reporter
		#
		if self.TICKET_PERMISSION_SYSTEM:
			if not self.check_permission(tkt, 'TICKET_CREATE'):
				print 'Reporter: %s has no permission to create tickets' %self.author
				return False

		# Old style setting for component, will be removed
		#
		if spam:
			tkt['component'] = 'Spam'

		elif self.parameters.has_key('component'):
			tkt['component'] = self.parameters['component']

		if not msg['Subject']:
			tkt['summary'] = u'(No subject)'
		else:
			tkt['summary'] = subject


		if set_fields:
			rest, keywords = string.split(set_fields, '?')

			if keywords:
				update_fields = self.str_to_dict(keywords)
				self.update_ticket_fields(tkt, update_fields)

		# produce e-mail like header
		#
		head = ''
		if self.EMAIL_HEADER > 0:
			head = self.email_header_txt(msg)

		message_parts = self.get_message_parts(msg)

		# Must we update some ticket fields properties via body_text
		#
		if self.properties:
				self.update_ticket_fields(tkt, self.properties)

		if self.DEBUG:
			print 'TD: self.get_message_parts ',
			print message_parts

		message_parts = self.unique_attachment_names(message_parts)
		if self.DEBUG:
			print 'TD: self.unique_attachment_names',
			print message_parts
		
		if self.EMAIL_HEADER > 0:
			message_parts.insert(0, self.email_header_txt(msg))
			
		body_text = self.body_text(message_parts)

		tkt['description'] = body_text

		#when = int(time.time())
		#
		utc = UTC()
		when = datetime.now(utc)

		if not self.DRY_RUN:
			self.id = tkt.insert()
	
		changed = False
		comment = ''

		# some routines in trac are dependend on ticket id	
		# like alternate notify template
		#
		if self.notify_template:
			tkt['id'] = self.id
			changed = True

		## Rewrite the description if we have mailto enabled
		#
		if self.MAILTO:
			changed = True
			comment = u'\nadded mailto line\n'
			mailto = self.html_mailto_link( m['Subject'])

			tkt['description'] = u'%s\r\n%s%s\r\n' \
				%(head, mailto, body_text)
	
		## Save the attachments to the ticket	
		#
		error_with_attachments =  self.attach_attachments(message_parts)

		if error_with_attachments:
			changed = True
			comment = '%s\n%s\n' %(comment, error_with_attachments)

		if changed:
			if self.DRY_RUN:
				print 'DRY_RUN: tkt.save_changes(%s, comment) real reporter = %s' %( tkt['reporter'], self.author)
			else:
				tkt.save_changes(tkt['reporter'], comment)
				#print tkt.get_changelog(self.db, when)

		if not spam:
			self.notify(tkt, True)


	def attach_attachments(self, message_parts, update=False):
		'''
		save any attachments as files in the ticket's directory
		'''
		if self.VERBOSE:
			print "VB: attach_attachments()"

		if self.DRY_RUN:
			print "DRY_RUN: no attachments attached to tickets"
			return ''

		count = 0

		# Get Maxium attachment size
		#
		max_size = int(self.get_config('attachment', 'max_size'))
		status   = None
		
		for item in message_parts:
			# Skip body parts
			if not isinstance(item, tuple):
				continue
				
			(original, filename, part) = item
			#
			# We have to determine the size so we use this temporary solution. we must escape it
			# else we get UnicodeErrors. 
			#
			path, fd =  util.create_unique_file(os.path.join(self.TMPDIR, util.text.unicode_quote(filename)))
			text = part.get_payload(decode=1)
			if not text:
				text = '(None)'
			fd.write(text)
			fd.close()

			# get the file_size
			#
			stats = os.lstat(path) 
			file_size = stats[stat.ST_SIZE]

			# Check if the attachment size is allowed
			#
			if (max_size != -1) and (file_size > max_size):
				status = '%s\nFile %s is larger then allowed attachment size (%d > %d)\n\n' \
					%(status, original, file_size, max_size)

				os.unlink(path)
				continue
			else:
				count = count + 1
					
			# Insert the attachment
			# 
			fd = open(path, 'rb')
			if self.system == 'discussion':
				att = attachment.Attachment(self.env, 'discussion', 'topic/%s'
				  % (self.id,))
			else:
				att = attachment.Attachment(self.env, 'ticket', self.id)
  
			# This will break the ticket_update system, the body_text is vaporized
			# ;-(
			#
			if not update:
				att.author = self.author
				att.description = self.email_to_unicode('Added by email2trac')

			try:
				att.insert(filename, fd, file_size)
			except OSError, detail:
				status = '%s\nFilename %s could not be saved, problem: %s' %(status, filename, detail)

			# Remove the created temporary filename
			#
			fd.close()
			os.unlink(path)

		## return error
		#
		return status

########## Fullblog functions  #################################################

	def blog(self, id): 
		"""
		The blog create/update function
		"""
		# import the modules
		#
		from tracfullblog.core import FullBlogCore
		from tracfullblog.model import BlogPost, BlogComment
		from trac.test import Mock, MockPerm

		# instantiate blog core
		blog = FullBlogCore(self.env)
		req = Mock(authname='anonymous', perm=MockPerm(), args={})

		if id: 

			# update blog
			#
			comment = BlogComment(self.env, id)
			comment.author = self.author

			message_parts = self.get_message_parts(m)
			comment.comment = self.body_text(message_parts)

			blog.create_comment(req, comment)

		else:
			# create blog
			#
			import time
			post = BlogPost(self.env, 'blog_'+time.strftime("%Y%m%d%H%M%S", time.gmtime()))

			#post = BlogPost(self.env, blog._get_default_postname(self.env)) 
			
			post.author = self.author
			post.title = self.email_to_unicode(m['Subject'])

			message_parts = self.get_message_parts(m)
			post.body = self.body_text(message_parts)
			
			blog.create_post(req, post, self.author, u'Created by email2trac', False)


########## Discussion functions  ##############################################

	def discussion_topic(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		if self.DEBUG:
			print 'TD: Creating a new topic in forum:', self.id

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get forum for new topic.
		forum = api.get_forum(context, self.id)

		if not forum and self.DEBUG:
			print 'ERROR: Replied forum doesn\'t exist'

		# Prepare topic.
		topic = {'forum' : forum['id'],
				 'subject' : context.subject,
				 'time': to_timestamp(datetime.now(utc)),
				 'author' : self.author,
				 'subscribers' : [self.email_addr],
				 'body' : self.body_text(context.content_parts)}

		# Add topic to DB and commit it.
		self._add_topic(api, context, topic)
		self.db.commit()

	def discussion_topic_reply(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		if self.DEBUG:
			print 'TD: Replying to discussion topic', self.id

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get replied topic.
		topic = api.get_topic(context, self.id)

		if not topic and self.DEBUG:
			print 'ERROR: Replied topic doesn\'t exist'

		# Prepare message.
		message = {'forum' : topic['forum'],
				   'topic' : topic['id'],
				   'replyto' : -1,
				   'time' : to_timestamp(datetime.now(utc)),
				   'author' : self.author,
				   'body' : self.body_text(context.content_parts)}

		# Add message to DB and commit it.
		self._add_message(api, context, message)
		self.db.commit()

	def discussion_message_reply(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		if self.DEBUG:
			print 'TD: Replying to discussion message', self.id

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get replied message.
		message = api.get_message(context, self.id)

		if not message and self.DEBUG:
			print 'ERROR: Replied message doesn\'t exist'

		# Prepare message.
		message = {'forum' : message['forum'],
				   'topic' : message['topic'],
				   'replyto' : message['id'],
				   'time' : to_timestamp(datetime.now(utc)),
				   'author' : self.author,
				   'body' : self.body_text(context.content_parts)}

		# Add message to DB and commit it.
		self._add_message(api, context, message)
		self.db.commit()

	def _create_context(self, content, subject):

		# Import modules.
		from trac.mimeview import Context
		from trac.web.api import Request
		from trac.perm import PermissionCache

		# TODO: Read server base URL from config.
		# Create request object to mockup context creation.
		#
		environ = {'SERVER_PORT' : 80,
				   'SERVER_NAME' : 'test',
				   'REQUEST_METHOD' : 'POST',
				   'wsgi.url_scheme' : 'http',
				   'wsgi.input' : sys.stdin}
		chrome =  {'links': {},
				   'scripts': [],
				   'ctxtnav': [],
				   'warnings': [],
				   'notices': []}

		if self.env.base_url_for_redirect:
			environ['trac.base_url'] = self.env.base_url

		req = Request(environ, None)
		req.chrome = chrome
		req.tz = 'missing'
		req.authname = self.author
		req.perm = PermissionCache(self.env, self.author)

		# Create and return context.
		context = Context.from_request(req)
		context.realm = 'discussion-email2trac'
		context.cursor = self.db.cursor()
		context.content = content
		context.subject = subject

		# Read content parts from content.
		context.content_parts = self.get_message_parts(content)
		context.content_parts = self.unique_attachment_names(
		  context.content_parts)

		return context

	def _add_topic(self, api, context, topic):
		context.req.perm.assert_permission('DISCUSSION_APPEND')

		# Filter topic.
		for discussion_filter in api.discussion_filters:
			accept, topic_or_error = discussion_filter.filter_topic(
			  context, topic)
			if accept:
				topic = topic_or_error
			else:
				raise TracError(topic_or_error)

		# Add a new topic.
		api.add_topic(context, topic)

		# Get inserted topic with new ID.
		topic = api.get_topic_by_time(context, topic['time'])

		# Attach attachments.
		self.id = topic['id']
		self.attach_attachments(context.content_parts, True)

		# Notify change listeners.
		for listener in api.topic_change_listeners:
			listener.topic_created(context, topic)

	def _add_message(self, api, context, message):
		context.req.perm.assert_permission('DISCUSSION_APPEND')

		# Filter message.
		for discussion_filter in api.discussion_filters:
			accept, message_or_error = discussion_filter.filter_message(
			  context, message)
			if accept:
				message = message_or_error
			else:
				raise TracError(message_or_error)

		# Add message.
		api.add_message(context, message)

		# Get inserted message with new ID.
		message = api.get_message_by_time(context, message['time'])

		# Attach attachments.
		self.id = message['topic']
		self.attach_attachments(context.content_parts, True)

		# Notify change listeners.
		for listener in api.message_change_listeners:
			listener.message_created(context, message)

########## MAIN function  ######################################################

	def parse(self, fp):
		"""
		"""
		self.logger.info('Main function parse')
		if self.VERBOSE:
			print "VB: main function parse()"
		global m

		m = email.message_from_file(fp)
		
		if not m:
			if self.DEBUG:
				print "TD: This is not a valid email message format"
			return
			
		# Work around lack of header folding in Python; see http://bugs.python.org/issue4696
		try:
			m.replace_header('Subject', m['Subject'].replace('\r', '').replace('\n', ''))
		except AttributeError, detail:
			pass

		if self.DEBUG > 1:	  # save the entire e-mail message text
			self.save_email_for_debug(m, True)

		self.db = self.env.get_db_cnx()
 		self.get_sender_info(m)

		if not self.email_header_acl('white_list', self.email_addr, True):
			if self.DEBUG > 1 :
 				print 'Message rejected : %s not in white list' %(self.email_addr)
			return False

		if self.email_header_acl('black_list', self.email_addr, False):
			if self.DEBUG > 1 :
 				print 'Message rejected : %s in black list' %(self.email_addr)
			return False

		if not self.email_header_acl('recipient_list', self.to_email_addr, True):
			if self.DEBUG > 1 :
 				print 'Message rejected : %s not in recipient list' %(self.to_email_addr)
			return False

		# If drop the message
		#
		if self.spam(m) == 'drop':
			return False

		elif self.spam(m) == 'spam':
			spam_msg = True
		else:
			spam_msg = False

		if not m['Subject']:
			subject  = 'No Subject'
		else:
			subject  = self.email_to_unicode(m['Subject'])

		if self.DEBUG:
			 print "TD:", subject

		#
		# [hic] #1529: Re: LRZ
		# [hic] #1529?owner=bas,priority=medium: Re: LRZ
		#
		ticket_regex = r'''
			(?P<new_fields>[#][?].*)
			|(?P<reply>(?P<id>[#][\d]+)(?P<fields>\?.*)?:)
			'''
		# Check if  FullBlogPlugin is installed
		#
		blog_enabled = None
		blog_regex = ''
		if self.get_config('components', 'tracfullblog.*') in ['enabled']:
			blog_enabled = True
		        blog_regex = '''|(?P<blog>blog:(?P<blog_id>\w*))'''


		# Check if DiscussionPlugin is installed
		#
		discussion_enabled = None
		discussion_regex = ''
		if self.get_config('components', 'tracdiscussion.api.*') in ['enabled']:
			discussion_enabled = True
			discussion_regex = r'''
			|(?P<forum>Forum[ ][#](?P<forum_id>\d+)[ ]-[ ]?)
			|(?P<topic>Topic[ ][#](?P<topic_id>\d+)[ ]-[ ]?)
			|(?P<message>Message[ ][#](?P<message_id>\d+)[ ]-[ ]?)
			'''


		regex_str = ticket_regex + blog_regex + discussion_regex
		SYSTEM_RE = re.compile(regex_str, re.VERBOSE)

		# Find out if this is a ticket, a blog or a discussion
		#
		result =  SYSTEM_RE.search(subject)

		if result:
			# update ticket + fields
			#
			if result.group('reply') and self.TICKET_UPDATE:
				self.system = 'ticket'

				# Skip the last ':' character
				#
				if not self.ticket_update(m, result.group('reply')[:-1], spam_msg):
					self.new_ticket(m, subject, spam_msg)

			# New ticket + fields
			#
			elif result.group('new_fields'):
				self.system = 'ticket'
				self.new_ticket(m, subject[:result.start('new_fields')], spam_msg, result.group('new_fields'))

			if blog_enabled: 
				if result.group('blog'):
					self.system = 'blog'
					self.blog(result.group('blog_id'))

			if discussion_enabled:
				# New topic.
				#
				if result.group('forum'):
					self.system = 'discussion'
					self.id = int(result.group('forum_id'))
					self.discussion_topic(m, subject[result.end('forum'):])

				# Reply to topic.
				#
				elif result.group('topic'): 
					self.system = 'discussion'
					self.id = int(result.group('topic_id'))
					self.discussion_topic_reply(m, subject[result.end('topic'):])

				# Reply to topic message.
				#
				elif result.group('message'):
					self.system = 'discussion'
					self.id = int(result.group('message_id'))
					self.discussion_message_reply(m, subject[result.end('message'):])

		else:
			self.system = 'ticket'
			result = self.ticket_update_by_subject(subject)
			if result:
				if not self.ticket_update(m, result, spam_msg):
					self.new_ticket(m, subject, spam_msg)
			else:
				# No update by subject, so just create a new ticket
				self.new_ticket(m, subject, spam_msg)


########## BODY TEXT functions  ###########################################################

	def strip_signature(self, text):
		"""
		Strip signature from message, inspired by Mailman software
		"""
		body = []
		for line in text.splitlines():
			if line == '-- ':
				break 
			body.append(line)

		return ('\n'.join(body))

	def reflow(self, text, delsp = 0):
		"""
		Reflow the message based on the format="flowed" specification (RFC 3676)
		"""
		flowedlines = []
		quotelevel = 0
		prevflowed = 0

		for line in text.splitlines():
			from re import match
			
			# Figure out the quote level and the content of the current line
			m = match('(>*)( ?)(.*)', line)
			linequotelevel = len(m.group(1))
			line = m.group(3)

			# Determine whether this line is flowed
			if line and line != '-- ' and line[-1] == ' ':
				flowed = 1
			else:
				flowed = 0

			if flowed and delsp and line and line[-1] == ' ':
				line = line[:-1]

			# If the previous line is flowed, append this line to it
			if prevflowed and line != '-- ' and linequotelevel == quotelevel:
				flowedlines[-1] += line
			# Otherwise, start a new line
			else:
				flowedlines.append('>' * linequotelevel + line)

			prevflowed = flowed
			

		return '\n'.join(flowedlines)

	def strip_quotes(self, text): 
		"""
		Strip quotes from message by Nicolas Mendoza
		"""
		body = [] 
		for line in text.splitlines():
			if line.startswith(self.EMAIL_QUOTE): 
				continue
			body.append(line)

		return ('\n'.join(body))

	def inline_properties(self, text): 
		"""
		Parse text if we use inline keywords to set ticket fields
		"""
		if self.DEBUG:
			print 'TD: inline_properties function'

		properties = dict()
		body = list()

		INLINE_EXP = re.compile('\s*[@]\s*([a-zA-Z]+)\s*:(.*)$')

		for line in text.splitlines():
			match = INLINE_EXP.match(line)
			if match:
				keyword, value = match.groups()
				self.properties[keyword] = value.strip()
				if self.DEBUG:
					print "TD: inline properties: %s : %s" %(keyword,value)
			else:
				body.append(line)
				
		return '\n'.join(body)


	def wrap_text(self, text, replace_whitespace = False):
		"""
		Will break a lines longer then given length into several small 
		lines of size given length
		"""
		import textwrap

		LINESEPARATOR = '\n'
		reformat = ''

		for s in text.split(LINESEPARATOR):
			tmp = textwrap.fill(s,self.USE_TEXTWRAP)
			if tmp:
				reformat = '%s\n%s' %(reformat,tmp)
			else:
				reformat = '%s\n' %reformat

		return reformat

		# Python2.4 and higher
		#
		#return LINESEPARATOR.join(textwrap.fill(s,width) for s in str.split(LINESEPARATOR))
		#

########## EMAIL attachements functions ###########################################################

	def inline_part(self, part):
		"""
		"""
		if self.VERBOSE:
			print "VB: inline_part()"

		return part.get_param('inline', None, 'Content-Disposition') == '' or not part.has_key('Content-Disposition')

	def get_message_parts(self, msg):
		"""
		parses the email message and returns a list of body parts and attachments
		body parts are returned as strings, attachments are returned as tuples of (filename, Message object)
		"""
		if self.VERBOSE:
			print "VB: get_message_parts()"

		message_parts = list()
	
		ALTERNATIVE_MULTIPART = False

		for part in msg.walk():
			if self.DEBUG:
				print 'TD: Message part: Main-Type: %s' % part.get_content_maintype()
				print 'TD: Message part: Content-Type: %s' % part.get_content_type()

			## Check content type
			# 
			if part.get_content_type() in self.STRIP_CONTENT_TYPES:

				if self.DEBUG:
					print "TD: A %s attachment named '%s' was skipped" %(part.get_content_type(), part.get_filename())

				continue

			## Catch some mulitpart execptions
			#
			if part.get_content_type() == 'multipart/alternative':
				ALTERNATIVE_MULTIPART = True
				continue

			## Skip multipart containers
			#
			if part.get_content_maintype() == 'multipart':
				if self.DEBUG:
					print "TD: Skipping multipart container"
				continue
			
			## Check if this is an inline part. It's inline if there is co Cont-Disp header, or if there is one and it says "inline"
			#
			inline = self.inline_part(part)

			## Drop HTML message
			#
			if ALTERNATIVE_MULTIPART and self.DROP_ALTERNATIVE_HTML_VERSION:
				if part.get_content_type() == 'text/html':
					if self.DEBUG:
						print "TD: Skipping alternative HTML message" 

			        	ALTERNATIVE_MULTIPART = False
					continue

			## Inline text parts are where the body is
			#
			if part.get_content_type() == 'text/plain' and inline:
				if self.DEBUG:
					print 'TD:               Inline body part'

				# Try to decode, if fails then do not decode
				#
				body_text = part.get_payload(decode=1)
				if not body_text:			
					body_text = part.get_payload(decode=0)

				format = email.Utils.collapse_rfc2231_value(part.get_param('Format', 'fixed')).lower()
				delsp = email.Utils.collapse_rfc2231_value(part.get_param('DelSp', 'no')).lower()

				if self.REFLOW and not self.VERBATIM_FORMAT and format == 'flowed':
					body_text = self.reflow(body_text, delsp == 'yes')
	
				if self.STRIP_SIGNATURE:
					body_text = self.strip_signature(body_text)

				if self.STRIP_QUOTES: 
					body_text = self.strip_quotes(body_text)

				if self.INLINE_PROPERTIES: 
					body_text = self.inline_properties(body_text)

				if self.USE_TEXTWRAP:
					body_text = self.wrap_text(body_text)

				## Get contents charset (iso-8859-15 if not defined in mail headers)
				#
				charset = part.get_content_charset()
				if not charset:
					charset = 'iso-8859-15'

				try:
					ubody_text = unicode(body_text, charset)

				except UnicodeError, detail:
					ubody_text = unicode(body_text, 'iso-8859-15')

				except LookupError, detail:
					ubody_text = 'ERROR: Could not find charset: %s, please install' %(charset)

				if self.VERBATIM_FORMAT:
					message_parts.append('{{{\r\n%s\r\n}}}' %ubody_text)
				else:
					message_parts.append('%s' %ubody_text)
			else:
				if self.DEBUG:
					s = 'TD:               Filename: %s' % part.get_filename()
					self.print_unicode(s)

				## 
				#  First try to use email header function to convert filename.
				#  If this fails the use the plan filename 
				try:
					filename = self.email_to_unicode(part.get_filename())
				except UnicodeEncodeError, detail:
					filename = part.get_filename()

				message_parts.append((filename, part))

		return message_parts
		
	def unique_attachment_names(self, message_parts):
		"""
		"""
		renamed_parts = []
		attachment_names = set()

		for item in message_parts:
			
			## If not an attachment, leave it alone
			#
			if not isinstance(item, tuple):
				renamed_parts.append(item)
				continue
				
			(filename, part) = item

			## If no filename, use a default one
			#
			if not filename:
				filename = 'untitled-part'

				# Guess the extension from the content type, use non strict mode
				# some additional non-standard but commonly used MIME types 
				# are also recognized
				#
				ext = mimetypes.guess_extension(part.get_content_type(), False)
				if not ext:
					ext = '.bin'

				filename = '%s%s' % (filename, ext)

			## Discard relative paths for windows/unix in attachment names
			#
			#filename = filename.replace('\\', '/').replace(':', '/') 
			filename = filename.replace('\\', '_')
			filename = filename.replace('/', '_') 

			#
			# We try to normalize the filename to utf-8 NFC if we can.
			# Files uploaded from OS X might be in NFD.
			# Check python version and then try it
			#
			#if sys.version_info[0] > 2 or (sys.version_info[0] == 2 and sys.version_info[1] >= 3):
			#	try:
			#		filename = unicodedata.normalize('NFC', unicode(filename, 'utf-8')).encode('utf-8')  
			#	except TypeError:
			#		pass

			# Make the filename unique for this ticket
			num = 0
			unique_filename = filename
			dummy_filename, ext = os.path.splitext(filename)

			while (unique_filename in attachment_names) or self.attachment_exists(unique_filename):
				num += 1
				unique_filename = "%s-%s%s" % (dummy_filename, num, ext)
				
			if self.DEBUG:
				s = 'TD: Attachment with filename %s will be saved as %s' % (filename, unique_filename)
				self.print_unicode(s)

			attachment_names.add(unique_filename)

			renamed_parts.append((filename, unique_filename, part))
	
		return renamed_parts
			
			
	def attachment_exists(self, filename):

		if self.DEBUG:
			s = 'TD: attachment already exists: Id : %s, Filename : %s' %(self.id, filename)
			self.print_unicode(s)

		# We have no valid ticket id
		#
		if not self.id:
			return False

		try:
			if self.system == 'discussion':
				att = attachment.Attachment(self.env, 'discussion', 'ticket/%s'
				  % (self.id,), filename)
			else:
				att = attachment.Attachment(self.env, 'ticket', self.id,
				  filename)
			return True
		except attachment.ResourceNotFound:
			return False

########## TRAC Ticket Text ###########################################################
			
	def body_text(self, message_parts):
		body_text = []
		
		for part in message_parts:
			# Plain text part, append it
			if not isinstance(part, tuple):
				body_text.extend(part.strip().splitlines())
				body_text.append("")
				continue
				
			(original, filename, part) = part
			inline = self.inline_part(part)
			
			if part.get_content_maintype() == 'image' and inline:
				if self.system != 'discussion':
					body_text.append('[[Image(%s)]]' % filename)
				body_text.append("")
			else:
				if self.system != 'discussion':
					body_text.append('[attachment:"%s"]' % filename)
				body_text.append("")
				
		body_text = '\r\n'.join(body_text)
		return body_text

	def html_mailto_link(self, subject):
		"""
		This function returns a HTML mailto tag with the ticket id and author email address
		"""
		if not self.author:
			author = self.email_addr
		else:	
			author = self.author

		# use urllib to escape the chars
		#
		s = 'mailto:%s?Subject=%s&Cc=%s' %( 
		       urllib.quote(self.email_addr), 
			   urllib.quote('Re: #%s: %s' %(self.id, subject)),
			   urllib.quote(self.MAILTO_CC)
			   )

		s = '\r\n{{{\r\n#!html\r\n<a\r\n href="%s">Reply to: %s\r\n</a>\r\n}}}\r\n' %(s, author)
		return s

########## TRAC notify section ###########################################################

	def notify(self, tkt, new=True, modtime=0):
		"""
		A wrapper for the TRAC notify function. So we can use templates
		"""
		if self.VERBOSE:
			print "VB: notify()"

		if self.DRY_RUN:
				print 'DRY_RUN: self.notify(tkt, True) reporter = %s' %tkt['reporter']
				return
		try:

			#from trac.ticket.web_ui import TicketModule
			#from trac.ticket.notification import TicketNotificationSystem
			#ticket_sys = TicketNotificationSystem(self.env)
			#a = TicketModule(self.env)
			#print a.__dict__
			#tn_sys = TicketNotificationSystem(self.env)
			#print tn_sys
			#print tn_sys.__dict__
			#sys.exit(0)

			# create false {abs_}href properties, to trick Notify()
			#
			if not (self.VERSION in [0.11, 0.12]):
				self.env.abs_href = Href(self.get_config('project', 'url'))
				self.env.href = Href(self.get_config('project', 'url'))


			tn = TicketNotifyEmail(self.env)

			if self.notify_template:

				if self.VERSION >= 0.11:

					from trac.web.chrome import Chrome

					if self.notify_template_update and not new:
						tn.template_name = self.notify_template_update
					else:
						tn.template_name = self.notify_template

					tn.template = Chrome(tn.env).load_template(tn.template_name, method='text')
						
				else:

					tn.template_name = self.notify_template;

			tn.notify(tkt, new, modtime) 

		except Exception, e:
			print 'TD: Failure sending notification on creation of ticket #%s: %s' %(self.id, e)



########## Parse Config File  ###########################################################

def ReadConfig(file, name):
	"""
	Parse the config file
	"""
	if not os.path.isfile(file):
		print 'File %s does not exist' %file
		sys.exit(1)

	config = trac_config.Configuration(file)

  	# Use given project name else use defaults
  	#
	if name:
		sections = config.sections()
		if not name in sections:
			print "Not a valid project name: %s" %name
			print "Valid names: %s" %sections
			sys.exit(1)

		project =  SaraDict()
		for option, value in  config.options(name):
			project[option] = value 

	else:
		# use some trac internals to get the defaults
		#
		tmp = config.parser.defaults()
		project =  SaraDict()

		for option,value in tmp.items():
			project[option] = value 

	return project


if __name__ == '__main__':
	# Default config file
	#
	configfile = '@email2trac_conf@'
	project = ''
	component = ''
	ticket_prefix = 'default'
	dry_run = None
	verbose = None

	ENABLE_SYSLOG = 0

	SHORT_OPT = 'chf:np:t:v'
	LONG_OPT  =  ['component=', 'dry-run', 'help', 'file=', 'project=', 'ticket_prefix=', 'verbose']

	try:
		opts, args = getopt.getopt(sys.argv[1:], SHORT_OPT, LONG_OPT)
	except getopt.error,detail:
		print __doc__
		print detail
		sys.exit(1)
	
	project_name = None
	for opt,value in opts:
		if opt in [ '-h', '--help']:
			print __doc__
			sys.exit(0)
		elif opt in ['-c', '--component']:
			component = value
		elif opt in ['-f', '--file']:
			configfile = value
		elif opt in ['-n', '--dry-run']:
			dry_run = True
		elif opt in ['-p', '--project']:
			project_name = value
		elif opt in ['-t', '--ticket_prefix']:
			ticket_prefix = value
		elif opt in ['-v', '--verbose']:
			verbose = True
	
	settings = ReadConfig(configfile, project_name)
	if not settings.has_key('project'):
		print __doc__
		print 'No Trac project is defined in the email2trac config file.'
		sys.exit(1)
	
	if component:
		settings['component'] = component

	# The default prefix for ticket values in email2trac.conf
	#
	settings['ticket_prefix'] = ticket_prefix
	settings['dry_run'] = dry_run
	settings['verbose'] = verbose


	# Determine major trac version used to be in email2trac.conf
	# Quick hack for 0.12
	#
	version = '0.%s' %(trac_version.split('.')[1])
	if version.startswith('0.12'):
		version = '0.12'

	if verbose:
		print "Found trac version: %s" %(version)
	
	#debug HvB
	#print settings

	try:
		if version == '0.10':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import util
			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail
			from trac import config as trac_config
			from trac.core import TracError

		elif version == '0.11':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import config as trac_config
			from trac import util
			from trac.core import TracError
			from trac.perm import PermissionSystem

			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail

		elif version == '0.12':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import config as trac_config
			from trac import util
			from trac.core import TracError
			from trac.perm import PermissionSystem

			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail


		else:
			print 'TRAC version %s is not supported' %version
			sys.exit(1)
			
		if settings.has_key('enable_syslog'):
			if SYSLOG_AVAILABLE:
				ENABLE_SYSLOG =  float(settings['enable_syslog']) 


		# Must be set before environment is created
		#
		if settings.has_key('python_egg_cache'):
			python_egg_cache = str(settings['python_egg_cache'])
			os.environ['PYTHON_EGG_CACHE'] = python_egg_cache

	
		if int(settings['debug']) > 0:
			print 'Loading environment', settings['project']

		env = Environment(settings['project'], create=0)

		tktparser = TicketEmailParser(env, settings, float(version))
		tktparser.parse(sys.stdin)

	# Catch all errors ans log to SYSLOG if we have enabled this
	# else stdout
	#
	except Exception, error:
		if ENABLE_SYSLOG:
			syslog.openlog('email2trac', syslog.LOG_NOWAIT)

			etype, evalue, etb = sys.exc_info()
			for e in traceback.format_exception(etype, evalue, etb):
				syslog.syslog(e)

			syslog.closelog()
		else:
			traceback.print_exc()

		if m:
			tktparser.save_email_for_debug(m, True)


		sys.exit(1)
# EOB
