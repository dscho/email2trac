#!@PYTHON@
# Copyright (C) 2002
#
# This file is part of the email2trac utils
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
#
# For vi/emacs or other use tabstop=4 (vi: set ts=4)
#
"""
email2trac.py -- Email tickets to Trac.

A simple MTA filter to create Trac tickets from inbound emails.

Copyright 2005, Daniel Lundin <daniel@edgewall.com>
Copyright 2005, Edgewall Software

Authors:
  Bas van der Vlies <basv@sara.nl>
  Walter de Jong <walter@sara.nl>

The scripts reads emails from stdin and inserts directly into a Trac database.

How to use
----------
 * See https://subtrac.sara.nl/oss/email2trac/

 * Create an config file:
    [DEFAULT]                        # REQUIRED
    project      : /data/trac/test   # REQUIRED
    debug        : 1                 # OPTIONAL, if set print some DEBUG info

    [jouvin]                         # OPTIONAL project declaration, if set both fields necessary
    project      : /data/trac/jouvin # use -p|--project jouvin.  
        
 * default config file is : /etc/email2trac.conf

 * Commandline opions:
                -h,--help
				-d, --debug 
                -f,--file  <configuration file>
                -n,--dry-run
                -p, --project <project name>
                -t, --ticket_prefix <name>

SVN Info:
        $Id$
"""
import os
import sys
import string
import getopt
import time
import email
import email.Iterators
import email.Header
import re
import urllib
import unicodedata
import mimetypes
import traceback
import logging
import logging.handlers
import UserDict

from datetime import tzinfo, timedelta, datetime
from stat import *


from trac import __version__ as trac_version
from trac import config as trac_config

# Some global variables
#
trac_default_version = '0.11'
m = None 

class SaraDict(UserDict.UserDict):
	def __init__(self, dictin = None):
		UserDict.UserDict.__init__(self)
		self.name = None 
		
		if dictin:
			if dictin.has_key('name'):
				self.name = dictin['name']
				del dictin['name']
			self.data = dictin 
			
	def get_value(self, name):
		if self.has_key(name):
			return self[name]
		else:
			return None 
				
	def __repr__(self):
		return repr(self.data) 

	def __str__(self):
		return str(self.data) 
			
	def __getattr__(self, name):
		"""
		override the class attribute get method. Return the value
		from the dictionary
		"""
		if self.data.has_key(name):
			return self.data[name] 
		else:
			return None
			
	def __setattr__(self, name, value):
		"""
		override the class attribute set method only when the UserDict
		has set its class attribute
		"""
		if self.__dict__.has_key('data'):
			self.data[name] = value
		else:
			self.__dict__[name] = value

	def __iter__(self):
		return iter(self.data.keys())

class TicketEmailParser(object):
	env = None
	comment = '> '

	def __init__(self, env, parameters, logger, version):
		self.env = env

		# Database connection
		#
		self.db = None

		# Save parameters
		#
		self.parameters = parameters
		self.logger = logger

		# Some useful mail constants
		#
		self.email_name = None
		self.email_addr = None
		self.email_from = None
		self.author     = None
		self.id         = None
		
		self.STRIP_CONTENT_TYPES = list()

		## fields properties via body_text
		#
		self.properties = dict()

		self.VERSION = version

		self.get_config = self.env.config.get

		## init function ##
		#
		self.setup_parameters()

	def setup_parameters(self):
		if self.parameters.umask:
			os.umask(self.parameters.umask)

		if not self.parameters.spam_level:
			self.parameters.spam_level = 0

		if not self.parameters.spam_header:
			self.parameters.spam_header = 'X-Spam-Score'

		if not self.parameters.email_quote:
			self.parameters.email_quote = '> '

		if not self.parameters.ticket_update_by_subject_lookback:
			self.parameters.ticket_update_by_subject_lookback = 30

		if self.parameters.verbatim_format == None:
			self.parameters.verbatim_format = 1

		if self.parameters.reflow == None:
			self.parameters.reflow = 1

		if self.parameters.binhex:
			self.STRIP_CONTENT_TYPES.append('application/mac-binhex40')

		if self.parameters.applesingle:
			self.STRIP_CONTENT_TYPES.append('application/applefile')

		if self.parameters.appledouble:
			self.STRIP_CONTENT_TYPES.append('application/applefile')

		if self.parameters.strip_content_types:
			items = self.parameters.strip_content_types.split(',')
			for item in items:
				self.STRIP_CONTENT_TYPES.append(item.strip())

		if self.parameters.tmpdir:
			self.parameters.tmpdir = os.path.normcase(str(self.parameters['tmpdir']))
		else:
			self.parameters.tmpdir = os.path.normcase('/tmp')

		if self.parameters.email_triggers_workflow == None:
			self.parameters.email_triggers_workflow = 1

		if not self.parameters.subject_field_separator:
			self.parameters.subject_field_separator = '&'
		else:
			self.parameters.subject_field_separator = self.parameters.subject_field_separator.strip()

		self.trac_smtp_from = self.get_config('notification', 'smtp_from')

		self.system = None

########## Email Header Functions ###########################################################

	def spam(self, message):
		"""
		# X-Spam-Score: *** (3.255) BAYES_50,DNS_FROM_AHBL_RHSBL,HTML_
		# Note if Spam_level then '*' are included
		"""
		spam = False
		if message.has_key(self.parameters.spam_header):
			spam_l = string.split(message[self.parameters.spam_header])

			try:
				number = spam_l[0].count('*')
			except IndexError, detail:
				number = 0
				
			if number >= self.parameters.spam_level:
				spam = True
				
		# treat virus mails as spam
		#
		elif message.has_key('X-Virus-found'):			
			spam = True

		# How to handle SPAM messages
		#
		if self.parameters.drop_spam and spam:

			self.logger.info('Message is a SPAM. Automatic ticket insertion refused (SPAM level > %d)' %self.parameters.spam_level)
			return 'drop'	

		elif spam:

			return 'Spam'	
		else:

			return False

	def email_header_acl(self, keyword, header_field, default):
		"""
		This function wil check if the email address is allowed or denied
		to send mail to the ticket list
	    """	
		self.logger.debug('function email_header_acl: %s' %keyword)

		try:
			mail_addresses = self.parameters[keyword]

			# Check if we have an empty string
			#
			if not mail_addresses:
				return default 

		except KeyError, detail:
			self.logger.debug('%s not defined, all messages are allowed.' %(keyword))

			return default 

		mail_addresses = string.split(mail_addresses, ',')

		for entry in mail_addresses:
			entry = entry.strip()
			TO_RE = re.compile(entry, re.VERBOSE|re.IGNORECASE)
			result =  TO_RE.search(header_field)
			if result:
				return True

		return False

	def email_header_txt(self, m):
		"""
		Display To and CC addresses in description field
		"""
		s = ''

		if m['To'] and len(m['To']) > 0:
			s = "'''To:''' %s\r\n" %(m['To'])
		if m['Cc'] and len(m['Cc']) > 0:
			s = "%s'''Cc:''' %s\r\n" % (s, m['Cc'])

		return  self.email_to_unicode(s)


	def get_sender_info(self, message):
		"""
		Get the default author name and email address from the message
		""" 

		self.email_to = self.email_to_unicode(message['to']) 
		self.to_name, self.to_email_addr = email.Utils.parseaddr (self.email_to) 

		self.email_from = self.email_to_unicode(message['from'])
		self.email_name, self.email_addr  = email.Utils.parseaddr(self.email_from)

		## Trac can not handle author's name that contains spaces
		#  and forbid the ticket email address as author field

		if self.email_addr == self.trac_smtp_from:
			if self.email_name:
				self.author = self.email_name
			else:
				self.author = "email2trac"
		else:
			self.author = self.email_addr

		if self.parameters.ignore_trac_user_settings:
			return

		# Is this a registered user, use email address as search key:
		# result:
		#   u : login name
		#   n : Name that the user has set in the settings tab
		#   e : email address that the user has set in the settings tab 
		#
		users = [ (u,n,e) for (u, n, e) in self.env.get_known_users(self.db)
			if e and (e.lower() == self.email_addr.lower()) ]

		if len(users) == 1:
			self.email_from = users[0][0]
			self.author = users[0][0]

	def set_reply_fields(self, ticket, message):
		"""
		Set all the right fields for a new ticket
		"""
		self.logger.debug('function set_reply_fields')

		## Only use name or email adress
		#ticket['reporter'] = self.email_from
		ticket['reporter'] = self.author


		# Put all CC-addresses in ticket CC field
		#
		if self.parameters.reply_all:

			email_cc = ''

			cc_addrs = email.Utils.getaddresses( message.get_all('cc', []) )

			if not cc_addrs:
				return

			## Build a list of forbidden CC addresses
			#
			#to_addrs = email.Utils.getaddresses( message.get_all('to', []) )
			#to_list = list()
			#for n,e in to_addrs:
			#	to_list.append(e)
				
			# Always Remove reporter email address from cc-list 
			#
			try:
				cc_addrs.remove((self.author, self.email_addr))
			except ValueError, detail:
				pass

			for name,addr in cc_addrs:
		
				## Prevent mail loop
				#
				#if addr in to_list:

				if addr == self.trac_smtp_from:
					self.logger.debug("Skipping %s mail address for CC-field" %(addr))
					continue

				if email_cc:
					email_cc = '%s, %s' %(email_cc, addr)
				else:
					email_cc = addr

			if email_cc:
				self.logger.debug('set_reply_fields: %s' %email_cc)

				ticket['cc'] = self.email_to_unicode(email_cc)


########## DEBUG functions  ###########################################################

	def debug_body(self, message_body, tempfile=False):
		if tempfile:
			import tempfile
			body_file = tempfile.mktemp('.email2trac')
		else:
			body_file = os.path.join(self.parameters.tmpdir, 'body.txt')

		if self.parameters.dry_run:
			print 'DRY-RUN: not saving body to %s' %(body_file)
			return

		print 'writing body to %s' %(body_file)
		fx = open(body_file, 'wb') 
		if not message_body:
				message_body = '(None)'

		message_body = message_body.encode('utf-8')
		#message_body = unicode(message_body, 'iso-8859-15')

		fx.write(message_body)
		fx.close()
		try:
			os.chmod(body_file,S_IRWXU|S_IRWXG|S_IRWXO)
		except OSError:
			pass

	def debug_attachments(self, message_parts):
		"""
		"""
		self.logger.debug('function debug_attachments')
		
		n = 0
		for item in message_parts:
			# Skip inline text parts
			if not isinstance(item, tuple):
				continue
				
			(original, filename, part) = item

			n = n + 1
			print 'part%d: Content-Type: %s' % (n, part.get_content_type())
		
			s = 'part%d: filename: %s' %(n, filename)
			self.print_unicode(s)
	
			## Forbidden chars
			#
			filename = filename.replace('\\', '_')
			filename = filename.replace('/', '_') 
	

			part_file = os.path.join(self.parameters.tmpdir, filename)
			s = 'writing part%d (%s)' % (n,part_file)
			self.print_unicode(s)

			if self.parameters.dry_run:
				print 'DRY_RUN: NOT saving attachments'
				continue

			part_file = util.text.unicode_quote(part_file)

			fx = open(part_file, 'wb')
			text = part.get_payload(decode=1)

			if not text:
				text = '(None)'

			fx.write(text)
			fx.close()

			try:
				os.chmod(part_file,S_IRWXU|S_IRWXG|S_IRWXO)
			except OSError:
				pass

	def save_email_for_debug(self, message, tempfile=False):

		if tempfile:
			import tempfile
			msg_file = tempfile.mktemp('.email2trac')
		else:
			#msg_file = '/var/tmp/msg.txt' 
			msg_file = os.path.join(self.parameters.tmpdir, 'msg.txt')

		if self.parameters.dry_run:
			print 'DRY_RUN: NOT saving email message to %s' %(msg_file)
		else:
			print 'saving email to %s' %(msg_file)

			fx = open(msg_file, 'wb')
			fx.write('%s' % message)
			fx.close()
			
			try:
				os.chmod(msg_file,S_IRWXU|S_IRWXG|S_IRWXO)
			except OSError:
				pass

		message_parts = self.get_message_parts(message)
		message_parts = self.unique_attachment_names(message_parts)
		body_text = self.body_text(message_parts)
		self.debug_body(body_text, True)
		self.debug_attachments(message_parts)

########## Conversion functions  ###########################################################

	def email_to_unicode(self, message_str):
		"""
		Email has 7 bit ASCII code, convert it to unicode with the charset
		that is encoded in 7-bit ASCII code and encode it as utf-8 so Trac 
		understands it.
		"""
		self.logger.debug("function email_to_unicode")

		results =  email.Header.decode_header(message_str)

		s = None
		for text,format in results:
			if format:
				try:
					temp = unicode(text, format)
				except UnicodeError, detail:
					# This always works 
					#
					temp = unicode(text, 'iso-8859-15')
				except LookupError, detail:
					#text = 'ERROR: Could not find charset: %s, please install' %format
					#temp = unicode(text, 'iso-8859-15')
					temp = message_str
				    	
			else:
				temp = string.strip(text)
				temp = unicode(text, 'iso-8859-15')

			if s:
				s = '%s %s' %(s, temp)
			else:
				s = '%s' %temp

		#s = s.encode('utf-8')
		return s

	def str_to_dict(self, s):
		"""
		Transfrom a string of the form [<key>=<value>]+ to dict[<key>] = <value>
		""" 
		self.logger.debug("function str_to_dict")

		fields = string.split(s, self.parameters.subject_field_separator)

		result = dict()
		for field in fields:
			try: 
				index, value = string.split(field, '=')

				# We can not change the description of a ticket via the subject
				# line. The description is the body of the email
				#
				if index.lower() in ['description']:
					continue

				if value:
					result[index.lower()] = value

			except ValueError:
				pass
		return result

	def print_unicode(self,s):
		"""
		This function prints unicode strings uif possible else it will quote it
		"""
		try:
			self.logger.debug(s)
		except UnicodeEncodeError, detail:
			self.logger.debug(util.text.unicode_quote(s))

########## TRAC ticket functions  ###########################################################

	def check_permission_participants(self, tkt):
		"""
		Check if the mailer is allowed to update the ticket
		"""
		self.logger.debug('function check_permission_participants')

		if tkt['reporter'].lower() in [self.author, self.email_addr]:
			self.logger.debug('ALLOW, %s is the ticket reporter' %(self.email_addr))

			return True

		perm = PermissionSystem(self.env)
		if perm.check_permission('TICKET_MODIFY', self.author):
			self.logger.debug('ALLOW, %s has trac permission to update the ticket' %(self.author))

			return True

		else:
			return False
		

		# Is the updater in the CC?
		try:
			cc_list = tkt['cc'].split(',')
			for cc in cc_list:
				if self.email_addr.lower() in cc.strip():
					self.logger.debug('ALLOW, %s is in the CC' %(self.email_addr))

					return True

		except KeyError:
			return False

	def check_permission(self, tkt, action):
		"""
		check if the reporter has the right permission for the action: 
          - TICKET_CREATE
          - TICKET_MODIFY

		There are three models:
  			- None      : no checking at all
			- trac      : check the permission via trac permission model
			- email2trac: ....
		"""
		self.logger.debug("function check_permission")

		if self.parameters.ticket_permission_system in ['trac']:

			perm = PermissionSystem(self.env)
			if perm.check_permission(action, self.author):
				return True
			else:
				return False

		elif self.parameters.ticket_permission_system in ['update_restricted_to_participants']:
			if action in ['TICKET_MODIFY']:
				return (self.check_permission_participants(tkt))	
			else:
				return True

		# Default is to allow everybody ticket updates and ticket creation
		else:
				return True


	def update_ticket_fields(self, ticket, user_dict, use_default=None): 
		"""
		This will update the ticket fields. It will check if the 
		given fields are known and if the right values are specified
		It will only update the ticket field value:
			- If the field is known
			- If the value supplied is valid for the ticket field.
			  If not then there are two options:
			   1) Skip the value (use_default=None)
			   2) Set default value for field (use_default=1)
		"""
		self.logger.debug("function update_ticket_fields")

		# Build a system dictionary from the ticket fields 
		# with field as index and option as value
		#
		sys_dict = dict()
		for field in ticket.fields:
			try:
				sys_dict[field['name']] = field['options']

			except KeyError:
				sys_dict[field['name']] = None
				pass

		## Check user supplied fields an compare them with the
		# system one's
		#
		for field,value in user_dict.items():
			if self.parameters.debug:
				s = 'user_field\t %s = %s' %(field,value) 
				self.print_unicode(s)

			## To prevent mail loop
			#
			if field == 'cc': 

				cc_list = user_dict['cc'].split(',')

				if self.trac_smtp_from in cc_list:
					self.logger.debug('MAIL LOOP: %s is not allowed as CC address' %(self.trac_smtp_from))

					cc_list.remove(self.trac_smtp_from)

				value = ','.join(cc_list)
				

			if sys_dict.has_key(field):

				# Check if value is an allowed system option, if TypeError then
				# every value is allowed
				#
				try:
					if value in sys_dict[field]:
						ticket[field] = value
					else:
						# Must we set a default if value is not allowed
						#
						if use_default:
							value = self.get_config('ticket', 'default_%s' %(field) )

				except TypeError:
					pass

				## Only set if we have a value
				#
				if value:
					ticket[field] = value

				if self.parameters.debug:
					s = 'ticket_field\t %s = %s' %(field,  ticket[field]) 
					self.print_unicode(s)

	def ticket_update(self, m, id, spam):
		"""
		If the current email is a reply to an existing ticket, this function
		will append the contents of this email to that ticket, instead of 
		creating a new one.
		"""
		self.logger.debug("function ticket_update")

		# Must we update ticket fields
		#
		update_fields = dict()
		try:
			id, keywords = string.split(id, '?')

			update_fields = self.str_to_dict(keywords)

			# Strip '#' 
			#
			self.id = int(id[1:])

		except ValueError:

			# Strip '#' 
			#
			self.id = int(id[1:])

		self.logger.debug("function ticket_update id %s" %id)

		# When is the change committed
		# 
		if self.VERSION < 0.11:
			when = int(time.time())
		else:
			when = datetime.now(util.datefmt.utc)

		try:
			tkt = Ticket(self.env, self.id, self.db)

		except util.TracError, detail:

			# Not a valid ticket

			self.id = None
			return False

		# Check the permission of the reporter
		#
		if self.parameters.ticket_permission_system:
			if not self.check_permission(tkt, 'TICKET_MODIFY'):
				self.logger.info('Reporter: %s has no permission to modify tickets' %self.author)
				return False

		# How many changes has this ticket
		cnum = len(tkt.get_changelog())


		# reopen the ticket if it is was closed
		# We must use the ticket workflow framework
		#
		if tkt['status'] in ['closed'] and self.parameters.email_triggers_workflow:

			#print controller.actions['reopen']
			#
			# As reference	
			# req = Mock(href=Href('/'), abs_href=Href('http://www.example.com/'), authname='anonymous', perm=MockPerm(), args={})
			#
			#a = controller.render_ticket_action_control(req, tkt, 'reopen')
			#print 'controller : ', a
			#
			#b = controller.get_all_status()
			#print 'get all status: ', b
			#
			#b = controller.get_ticket_changes(req, tkt, 'reopen')
			#print 'get_ticket_changes :', b

			if self.parameters.has_key.workflow and (self.VERSION >= 0.11 ) :
				from trac.ticket.default_workflow import ConfigurableTicketWorkflow
				from trac.test import Mock, MockPerm

				req = Mock(authname='anonymous', perm=MockPerm(), args={})

				controller = ConfigurableTicketWorkflow(self.env)
				fields = controller.get_ticket_changes(req, tkt, self.parameters.has_key.workflow)

				self.logger.debug('Workflow ticket update fields: ')

				for key in fields.keys():
					self.logger.debug('\t %s : %s' %(key, fields[key]))
					tkt[key] = fields[key]

			else:
				tkt['status'] = 'reopened'
				tkt['resolution'] = ''

		# Must we update some ticket fields properties via subjectline
		#
		if update_fields:
			self.update_ticket_fields(tkt, update_fields)

		message_parts = self.get_message_parts(m)
		message_parts = self.unique_attachment_names(message_parts)

		# Must we update some ticket fields properties via body_text
		#
		if self.properties:
				self.update_ticket_fields(tkt, self.properties)

		if self.parameters.email_header:
			message_parts.insert(0, self.email_header_txt(m))

		body_text = self.body_text(message_parts)

		error_with_attachments = self.attach_attachments(message_parts)

		if body_text.strip() or update_fields or self.properties: 
			if self.parameters.dry_run:
				print 'DRY_RUN: tkt.save_changes(self.author, body_text, ticket_change_number) ', self.author, cnum
			else:
				if error_with_attachments:
					body_text = '%s\\%s' %(error_with_attachments, body_text)
				self.logger.debug('tkt.save_changes(%s, %d)' %(self.author, cnum))
				tkt.save_changes(self.author, body_text, when, None, str(cnum))
			

		if not spam:
			self.notify(tkt, False, when)

		return True

	def set_ticket_fields(self, ticket):
		"""
		set the ticket fields to value specified
			- /etc/email2trac.conf with <prefix>_<field>
			- trac default values, trac.ini
		"""
		self.logger.debug('function set_ticket_fields')

		user_dict = dict()

		for field in ticket.fields:

			name = field['name'] 

			## default trac value
			#
			if not field.get('custom'):
				value = self.get_config('ticket', 'default_%s' %(name) )
			else:
				##  Else we get the default value for reporter
				#
				value = field.get('value')
				options = field.get('options')

				if value and options and (value not in options):
					 value = options[int(value)]
	
			if self.parameters.debug:
				s = 'trac[%s] = %s' %(name, value)
				self.print_unicode(s)

			## email2trac.conf settings
			#
			prefix = self.parameters['ticket_prefix']
			try:
				value = self.parameters['%s_%s' %(prefix, name)]
				if self.parameters.debug > 10:
					s = 'email2trac[%s] = %s ' %(name, value)
					self.print_unicode(s)

			except KeyError, detail:
				pass
		
			if self.parameters.debug:
				s = 'used %s = %s' %(name, value)
				self.print_unicode(s)

			if value:
				user_dict[name] = value

		self.update_ticket_fields(ticket, user_dict, use_default=1)

		if 'status' not in user_dict.keys():
			ticket['status'] = 'new'


	def ticket_update_by_subject(self, subject):
		"""
		This list of Re: prefixes is probably incomplete. Taken from
		wikipedia. Here is how the subject is matched
		  - Re: <subject> 
		  - Re: (<Mail list label>:)+ <subject>

		So we must have the last column
		"""
		self.logger.debug('function ticket_update_by_subject')

		matched_id = None
		if self.parameters.ticket_update and self.parameters.ticket_update_by_subject:
				
			SUBJECT_RE = re.compile(r'^(RE|AW|VS|SV):(.*:)*\s*(.*)', re.IGNORECASE)
			result = SUBJECT_RE.search(subject)

			if result:
				# This is a reply
				orig_subject = result.group(3)

				self.logger.debug('subject search string: %s' %(orig_subject))

				cursor = self.db.cursor()
				summaries = [orig_subject, '%%: %s' % orig_subject]

				##
				# Convert days to seconds
				lookback = int(time.mktime(time.gmtime())) - \
						self.parameters.ticket_update_by_subject_lookback * 24 * 3600


				for summary in summaries:
					self.logger.debug('Looking for summary matching: "%s"' % summary)

					sql = """SELECT id FROM ticket
						 	WHERE changetime >= %s AND summary LIKE %s
							ORDER BY changetime DESC"""
					cursor.execute(sql, [lookback, summary.strip()])

					for row in cursor:
						(matched_id,) = row

						self.logger.debug('Found matching ticket id: %d' % matched_id)

						break

					if matched_id:
						matched_id = '#%d' % matched_id
						return matched_id

		return matched_id


	def new_ticket(self, msg, subject, spam, set_fields = None):
		"""
		Create a new ticket
		"""
		self.logger.debug('function new_ticket')

		tkt = Ticket(self.env)

		self.set_reply_fields(tkt, msg)

		self.set_ticket_fields(tkt)

		# Check the permission of the reporter
		#
		if self.parameters.ticket_permission_system:
			if not self.check_permission(tkt, 'TICKET_CREATE'):
				self.logger.info('Reporter: %s has no permission to create tickets' %self.author)
				return False

		# Old style setting for component, will be removed
		#
		if spam:
			tkt['component'] = 'Spam'

		elif self.parameters.has_key('component'):
			tkt['component'] = self.parameters['component']

		if not msg['Subject']:
			tkt['summary'] = u'(No subject)'
		else:
			tkt['summary'] = subject


		if set_fields:
			rest, keywords = string.split(set_fields, '?')

			if keywords:
				update_fields = self.str_to_dict(keywords)
				self.update_ticket_fields(tkt, update_fields)


		message_parts = self.get_message_parts(msg)

		# Must we update some ticket fields properties via body_text
		#
		if self.properties:
				self.update_ticket_fields(tkt, self.properties)

		message_parts = self.unique_attachment_names(message_parts)
		
		# produce e-mail like header
		#
		head = ''
		if self.parameters.email_header:
			head = self.email_header_txt(msg)
			message_parts.insert(0, head)
			
		body_text = self.body_text(message_parts)

		tkt['description'] = body_text

		# When is the change committed
		# 
		if self.VERSION < 0.11:
			when = int(time.time())
		else:
			when = datetime.now(util.datefmt.utc)

		if self.parameters.dry_run:
			print 'DRY_RUN: tkt.insert()'
		else:
			self.id = tkt.insert()
	
		changed = False
		comment = ''

		# some routines in trac are dependend on ticket id	
		# like alternate notify template
		#
		if self.parameters.alternate_notify_template:
			tkt['id'] = self.id
			changed = True

		## Rewrite the description if we have mailto enabled
		#
		if self.parameters.mailto_link:
			changed = True
			comment = u'\nadded mailto line\n'
			mailto = self.html_mailto_link( m['Subject'])

			tkt['description'] = u'%s\r\n%s%s\r\n' \
				%(head, mailto, body_text)
	
		## Save the attachments to the ticket	
		#
		error_with_attachments =  self.attach_attachments(message_parts)

		if error_with_attachments:
			changed = True
			comment = '%s\n%s\n' %(comment, error_with_attachments)

		if changed:
			if self.parameters.dry_run:
				print 'DRY_RUN: tkt.save_changes(%s, comment) real reporter = %s' %( tkt['reporter'], self.author)
			else:
				tkt.save_changes(tkt['reporter'], comment)
				#print tkt.get_changelog(self.db, when)

		if not spam:
			self.notify(tkt, True)


	def attach_attachments(self, message_parts, update=False):
		'''
		save any attachments as files in the ticket's directory
		'''
		self.logger.debug('function attach_attachments()')

		if self.parameters.dry_run:
			print "DRY_RUN: no attachments attached to tickets"
			return ''

		count = 0

		# Get Maxium attachment size
		#
		max_size = int(self.get_config('attachment', 'max_size'))
		status   = None
		
		for item in message_parts:
			# Skip body parts
			if not isinstance(item, tuple):
				continue
				
			(original, filename, part) = item
			#
			# We have to determine the size so we use this temporary solution. we must escape it
			# else we get UnicodeErrors. 
			#
			path, fd =  util.create_unique_file(os.path.join(self.parameters.tmpdir, util.text.unicode_quote(filename)))
			text = part.get_payload(decode=1)
			if not text:
				text = '(None)'
			fd.write(text)
			fd.close()

			# get the file_size
			#
			stats = os.lstat(path) 
			file_size = stats[ST_SIZE]

			# Check if the attachment size is allowed
			#
			if (max_size != -1) and (file_size > max_size):
				status = '%s\nFile %s is larger then allowed attachment size (%d > %d)\n\n' \
					%(status, original, file_size, max_size)

				os.unlink(path)
				continue
			else:
				count = count + 1
					
			# Insert the attachment
			# 
			fd = open(path, 'rb')
			if self.system == 'discussion':
				att = attachment.Attachment(self.env, 'discussion', 'topic/%s'
				  % (self.id,))
			else:
				self.logger.debug('Attach %s to ticket %d' %(util.text.unicode_quote(filename), self.id))
				att = attachment.Attachment(self.env, 'ticket', self.id)
  
			# This will break the ticket_update system, the body_text is vaporized
			# ;-(
			#
			if not update:
				att.author = self.author
				att.description = self.email_to_unicode('Added by email2trac')

			try:
				self.logger.debug('Insert atachment')
				att.insert(filename, fd, file_size)
			except OSError, detail:
				self.logger.info('%s\nFilename %s could not be saved, problem: %s' %(status, filename, detail))
				status = '%s\nFilename %s could not be saved, problem: %s' %(status, filename, detail)

			# Remove the created temporary filename
			#
			fd.close()
			os.unlink(path)

		## return error
		#
		return status

########## Fullblog functions  #################################################

	def blog(self, id): 
		"""
		The blog create/update function
		"""
		# import the modules
		#
		from tracfullblog.core import FullBlogCore
		from tracfullblog.model import BlogPost, BlogComment
		from trac.test import Mock, MockPerm

		# instantiate blog core
		blog = FullBlogCore(self.env)
		req = Mock(authname='anonymous', perm=MockPerm(), args={})

		if id: 

			# update blog
			#
			comment = BlogComment(self.env, id)
			comment.author = self.author

			message_parts = self.get_message_parts(m)
			comment.comment = self.body_text(message_parts)

			blog.create_comment(req, comment)

		else:
			# create blog
			#
			import time
			post = BlogPost(self.env, 'blog_'+time.strftime("%Y%m%d%H%M%S", time.gmtime()))

			#post = BlogPost(self.env, blog._get_default_postname(self.env)) 
			
			post.author = self.author
			post.title = self.email_to_unicode(m['Subject'])

			message_parts = self.get_message_parts(m)
			post.body = self.body_text(message_parts)
			
			blog.create_post(req, post, self.author, u'Created by email2trac', False)


########## Discussion functions  ##############################################

	def discussion_topic(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		self.logger.debug('Creating a new topic in forum:', self.id)

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get forum for new topic.
		forum = api.get_forum(context, self.id)

		if not forum:
			self.logger.error("ERROR: Replied forum doesn't exist")

		# Prepare topic.
		topic = {'forum' : forum['id'],
				 'subject' : context.subject,
				 'time': to_timestamp(datetime.now(utc)),
				 'author' : self.author,
				 'subscribers' : [self.email_addr],
				 'body' : self.body_text(context.content_parts)}

		# Add topic to DB and commit it.
		self._add_topic(api, context, topic)
		self.db.commit()

	def discussion_topic_reply(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		self.logger.debug('Replying to discussion topic', self.id)

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get replied topic.
		topic = api.get_topic(context, self.id)

		if not topic:
			self.logger.error("ERROR: Replied topic doesn't exist")

		# Prepare message.
		message = {'forum' : topic['forum'],
				   'topic' : topic['id'],
				   'replyto' : -1,
				   'time' : to_timestamp(datetime.now(utc)),
				   'author' : self.author,
				   'body' : self.body_text(context.content_parts)}

		# Add message to DB and commit it.
		self._add_message(api, context, message)
		self.db.commit()

	def discussion_message_reply(self, content, subject):

		# Import modules.
		from tracdiscussion.api import DiscussionApi
		from trac.util.datefmt import to_timestamp, utc

		self.loggger.debug('Replying to discussion message', self.id)

		# Get dissussion API component.
		api = self.env[DiscussionApi]
		context = self._create_context(content, subject)

		# Get replied message.
		message = api.get_message(context, self.id)

		if not message:
			self.logger.error("ERROR: Replied message doesn't exist")

		# Prepare message.
		message = {'forum' : message['forum'],
				   'topic' : message['topic'],
				   'replyto' : message['id'],
				   'time' : to_timestamp(datetime.now(utc)),
				   'author' : self.author,
				   'body' : self.body_text(context.content_parts)}

		# Add message to DB and commit it.
		self._add_message(api, context, message)
		self.db.commit()

	def _create_context(self, content, subject):

		# Import modules.
		from trac.mimeview import Context
		from trac.web.api import Request
		from trac.perm import PermissionCache

		# TODO: Read server base URL from config.
		# Create request object to mockup context creation.
		#
		environ = {'SERVER_PORT' : 80,
				   'SERVER_NAME' : 'test',
				   'REQUEST_METHOD' : 'POST',
				   'wsgi.url_scheme' : 'http',
				   'wsgi.input' : sys.stdin}
		chrome =  {'links': {},
				   'scripts': [],
				   'ctxtnav': [],
				   'warnings': [],
				   'notices': []}

		if self.env.base_url_for_redirect:
			environ['trac.base_url'] = self.env.base_url

		req = Request(environ, None)
		req.chrome = chrome
		req.tz = 'missing'
		req.authname = self.author
		req.perm = PermissionCache(self.env, self.author)

		# Create and return context.
		context = Context.from_request(req)
		context.realm = 'discussion-email2trac'
		context.cursor = self.db.cursor()
		context.content = content
		context.subject = subject

		# Read content parts from content.
		context.content_parts = self.get_message_parts(content)
		context.content_parts = self.unique_attachment_names(
		  context.content_parts)

		return context

	def _add_topic(self, api, context, topic):
		context.req.perm.assert_permission('DISCUSSION_APPEND')

		# Filter topic.
		for discussion_filter in api.discussion_filters:
			accept, topic_or_error = discussion_filter.filter_topic(
			  context, topic)
			if accept:
				topic = topic_or_error
			else:
				raise TracError(topic_or_error)

		# Add a new topic.
		api.add_topic(context, topic)

		# Get inserted topic with new ID.
		topic = api.get_topic_by_time(context, topic['time'])

		# Attach attachments.
		self.id = topic['id']
		self.attach_attachments(context.content_parts, True)

		# Notify change listeners.
		for listener in api.topic_change_listeners:
			listener.topic_created(context, topic)

	def _add_message(self, api, context, message):
		context.req.perm.assert_permission('DISCUSSION_APPEND')

		# Filter message.
		for discussion_filter in api.discussion_filters:
			accept, message_or_error = discussion_filter.filter_message(
			  context, message)
			if accept:
				message = message_or_error
			else:
				raise TracError(message_or_error)

		# Add message.
		api.add_message(context, message)

		# Get inserted message with new ID.
		message = api.get_message_by_time(context, message['time'])

		# Attach attachments.
		self.id = message['topic']
		self.attach_attachments(context.content_parts, True)

		# Notify change listeners.
		for listener in api.message_change_listeners:
			listener.message_created(context, message)

########## MAIN function  ######################################################

	def parse(self, fp):
		"""
		"""
		self.logger.debug('Main function parse')
		global m

		m = email.message_from_file(fp)
		
		if not m:
			self.logger.debug('This is not a valid email message format')
			return
			
		# Work around lack of header folding in Python; see http://bugs.python.org/issue4696
		try:
			m.replace_header('Subject', m['Subject'].replace('\r', '').replace('\n', ''))
		except AttributeError, detail:
			pass

		if self.parameters.debug:	  # save the entire e-mail message text
			self.save_email_for_debug(m, True)

		self.db = self.env.get_db_cnx()
 		self.get_sender_info(m)

		if not self.email_header_acl('white_list', self.email_addr, True):
			self.logger.info('Message rejected : %s not in white list' %(self.email_addr))
			return False

		if self.email_header_acl('black_list', self.email_addr, False):
			self.logger.info('Message rejected : %s in black list' %(self.email_addr))
			return False

		if not self.email_header_acl('recipient_list', self.to_email_addr, True):
			self.logger.info('Message rejected : %s not in recipient list' %(self.to_email_addr))
			return False

		# If spam drop the message
		#
		if self.spam(m) == 'drop':
			return False

		elif self.spam(m) == 'spam':
			spam_msg = True
		else:
			spam_msg = False

		if not m['Subject']:
			subject  = 'No Subject'
		else:
			subject  = self.email_to_unicode(m['Subject'])

		self.logger.debug('subject: %s' %subject)

		#
		# [hic] #1529: Re: LRZ
		# [hic] #1529?owner=bas,priority=medium: Re: LRZ
		#
		ticket_regex = r'''
			(?P<new_fields>[#][?].*)
			|(?P<reply>(?P<id>[#][\d]+)(?P<fields>\?.*)?:)
			'''
		# Check if  FullBlogPlugin is installed
		#
		blog_enabled = None
		blog_regex = ''
		if self.get_config('components', 'tracfullblog.*') in ['enabled']:
			blog_enabled = True
		        blog_regex = '''|(?P<blog>blog:(?P<blog_id>\w*))'''


		# Check if DiscussionPlugin is installed
		#
		discussion_enabled = None
		discussion_regex = ''
		if self.get_config('components', 'tracdiscussion.api.*') in ['enabled']:
			discussion_enabled = True
			discussion_regex = r'''
			|(?P<forum>Forum[ ][#](?P<forum_id>\d+)[ ]-[ ]?)
			|(?P<topic>Topic[ ][#](?P<topic_id>\d+)[ ]-[ ]?)
			|(?P<message>Message[ ][#](?P<message_id>\d+)[ ]-[ ]?)
			'''


		regex_str = ticket_regex + blog_regex + discussion_regex
		SYSTEM_RE = re.compile(regex_str, re.VERBOSE)

		# Find out if this is a ticket, a blog or a discussion
		#
		result =  SYSTEM_RE.search(subject)

		if result:
			# update ticket + fields
			#
			if result.group('reply') and self.parameters.ticket_update:
				self.system = 'ticket'

				# Skip the last ':' character
				#
				if not self.ticket_update(m, result.group('reply')[:-1], spam_msg):
					self.new_ticket(m, subject, spam_msg)

			# New ticket + fields
			#
			elif result.group('new_fields'):
				self.system = 'ticket'
				self.new_ticket(m, subject[:result.start('new_fields')], spam_msg, result.group('new_fields'))

			if blog_enabled: 
				if result.group('blog'):
					self.system = 'blog'
					self.blog(result.group('blog_id'))

			if discussion_enabled:
				# New topic.
				#
				if result.group('forum'):
					self.system = 'discussion'
					self.id = int(result.group('forum_id'))
					self.discussion_topic(m, subject[result.end('forum'):])

				# Reply to topic.
				#
				elif result.group('topic'): 
					self.system = 'discussion'
					self.id = int(result.group('topic_id'))
					self.discussion_topic_reply(m, subject[result.end('topic'):])

				# Reply to topic message.
				#
				elif result.group('message'):
					self.system = 'discussion'
					self.id = int(result.group('message_id'))
					self.discussion_message_reply(m, subject[result.end('message'):])

		else:
			self.system = 'ticket'
			result = self.ticket_update_by_subject(subject)
			if result:
				if not self.ticket_update(m, result, spam_msg):
					self.new_ticket(m, subject, spam_msg)
			else:
				# No update by subject, so just create a new ticket
				self.new_ticket(m, subject, spam_msg)


########## BODY TEXT functions  ###########################################################

	def strip_signature(self, text):
		"""
		Strip signature from message, inspired by Mailman software
		"""
		body = []
		for line in text.splitlines():
			if line == '-- ':
				break 
			body.append(line)

		return ('\n'.join(body))

	def reflow(self, text, delsp = 0):
		"""
		Reflow the message based on the format="flowed" specification (RFC 3676)
		"""
		flowedlines = []
		quotelevel = 0
		prevflowed = 0

		for line in text.splitlines():
			from re import match
			
			# Figure out the quote level and the content of the current line
			m = match('(>*)( ?)(.*)', line)
			linequotelevel = len(m.group(1))
			line = m.group(3)

			# Determine whether this line is flowed
			if line and line != '-- ' and line[-1] == ' ':
				flowed = 1
			else:
				flowed = 0

			if flowed and delsp and line and line[-1] == ' ':
				line = line[:-1]

			# If the previous line is flowed, append this line to it
			if prevflowed and line != '-- ' and linequotelevel == quotelevel:
				flowedlines[-1] += line
			# Otherwise, start a new line
			else:
				flowedlines.append('>' * linequotelevel + line)

			prevflowed = flowed
			

		return '\n'.join(flowedlines)

	def strip_quotes(self, text): 
		"""
		Strip quotes from message by Nicolas Mendoza
		"""
		body = [] 
		for line in text.splitlines():
			if line.startswith(self.parameters.email_quote): 
				continue
			body.append(line)

		return ('\n'.join(body))

	def inline_properties(self, text): 
		"""
		Parse text if we use inline keywords to set ticket fields
		"""
		self.logger.debug('function inline_properties')

		properties = dict()
		body = list()

		INLINE_EXP = re.compile('\s*[@]\s*([a-zA-Z]+)\s*:(.*)$')

		for line in text.splitlines():
			match = INLINE_EXP.match(line)
			if match:
				keyword, value = match.groups()
				self.properties[keyword] = value.strip()

				self.logger.debug('inline properties: %s : %s' %(keyword,value))

			else:
				body.append(line)
				
		return '\n'.join(body)


	def wrap_text(self, text, replace_whitespace = False):
		"""
		Will break a lines longer then given length into several small 
		lines of size given length
		"""
		import textwrap

		LINESEPARATOR = '\n'
		reformat = ''

		for s in text.split(LINESEPARATOR):
			tmp = textwrap.fill(s, self.parameters.use_textwrap)
			if tmp:
				reformat = '%s\n%s' %(reformat,tmp)
			else:
				reformat = '%s\n' %reformat

		return reformat

		# Python2.4 and higher
		#
		#return LINESEPARATOR.join(textwrap.fill(s,width) for s in str.split(LINESEPARATOR))
		#

########## EMAIL attachements functions ###########################################################

	def inline_part(self, part):
		"""
		"""
		self.logger.debug('function inline_part()')

		return part.get_param('inline', None, 'Content-Disposition') == '' or not part.has_key('Content-Disposition')

	def get_message_parts(self, msg):
		"""
		parses the email message and returns a list of body parts and attachments
		body parts are returned as strings, attachments are returned as tuples of (filename, Message object)
		"""
		self.logger.debug('function get_message_parts()')

		message_parts = list()
	
		ALTERNATIVE_MULTIPART = False

		for part in msg.walk():
			self.logger.debug('Message part: Main-Type: %s' % part.get_content_maintype())
			self.logger.debug('Message part: Content-Type: %s' % part.get_content_type())

			## Check content type
			# 
			if part.get_content_type() in self.STRIP_CONTENT_TYPES:
				self.logger.debug("A %s attachment named '%s' was skipped" %(part.get_content_type(), part.get_filename()))
				continue

			## Catch some mulitpart execptions
			#
			if part.get_content_type() == 'multipart/alternative':
				ALTERNATIVE_MULTIPART = True
				continue

			## Skip multipart containers
			#
			if part.get_content_maintype() == 'multipart':
				self.logger.debug("Skipping multipart container")

				continue
			
			## Check if this is an inline part. It's inline if there is co Cont-Disp header, or if there is one and it says "inline"
			#
			inline = self.inline_part(part)

			## Drop HTML message
			#
			if ALTERNATIVE_MULTIPART and self.parameters.drop_alternative_html_version:
				if part.get_content_type() == 'text/html':
					self.logger.debug('Skipping alternative HTML message')
					ALTERNATIVE_MULTIPART = False
					continue

			## Inline text parts are where the body is
			#
			if part.get_content_type() == 'text/plain' and inline:
				self.logger.debug('               Inline body part')

				# Try to decode, if fails then do not decode
				#
				body_text = part.get_payload(decode=1)
				if not body_text:			
					body_text = part.get_payload(decode=0)

				format = email.Utils.collapse_rfc2231_value(part.get_param('Format', 'fixed')).lower()
				delsp = email.Utils.collapse_rfc2231_value(part.get_param('DelSp', 'no')).lower()

				if self.parameters.reflow and not self.parameters.verbatim_format and format == 'flowed':
					body_text = self.reflow(body_text, delsp == 'yes')
	
				if self.parameters.strip_signature:
					body_text = self.strip_signature(body_text)

				if self.parameters.strip_quotes: 
					body_text = self.strip_quotes(body_text)

				if self.parameters.inline_properties: 
					body_text = self.inline_properties(body_text)

				if self.parameters.use_textwrap:
					body_text = self.wrap_text(body_text)

				## Get contents charset (iso-8859-15 if not defined in mail headers)
				#
				charset = part.get_content_charset()
				if not charset:
					charset = 'iso-8859-15'

				try:
					ubody_text = unicode(body_text, charset)

				except UnicodeError, detail:
					ubody_text = unicode(body_text, 'iso-8859-15')

				except LookupError, detail:
					ubody_text = 'ERROR: Could not find charset: %s, please install' %(charset)

				if self.parameters.verbatim_format:
					message_parts.append('{{{\r\n%s\r\n}}}' %ubody_text)
				else:
					message_parts.append('%s' %ubody_text)
			else:
				if self.parameters.debug:
					s = '              Filename: %s' % part.get_filename()
					self.print_unicode(s)

				## 
				#  First try to use email header function to convert filename.
				#  If this fails the use the plan filename 
				try:
					filename = self.email_to_unicode(part.get_filename())
				except UnicodeEncodeError, detail:
					filename = part.get_filename()

				message_parts.append((filename, part))

		return message_parts
		
	def unique_attachment_names(self, message_parts):
		"""
		"""
		renamed_parts = []
		attachment_names = set()

		for item in message_parts:
			
			## If not an attachment, leave it alone
			#
			if not isinstance(item, tuple):
				renamed_parts.append(item)
				continue
				
			(filename, part) = item

			## If no filename, use a default one
			#
			if not filename:
				filename = 'untitled-part'

				# Guess the extension from the content type, use non strict mode
				# some additional non-standard but commonly used MIME types 
				# are also recognized
				#
				ext = mimetypes.guess_extension(part.get_content_type(), False)
				if not ext:
					ext = '.bin'

				filename = '%s%s' % (filename, ext)

			## Discard relative paths for windows/unix in attachment names
			#
			#filename = filename.replace('\\', '/').replace(':', '/') 
			filename = filename.replace('\\', '_')
			filename = filename.replace('/', '_') 

			#
			# We try to normalize the filename to utf-8 NFC if we can.
			# Files uploaded from OS X might be in NFD.
			# Check python version and then try it
			#
			#if sys.version_info[0] > 2 or (sys.version_info[0] == 2 and sys.version_info[1] >= 3):
			#	try:
			#		filename = unicodedata.normalize('NFC', unicode(filename, 'utf-8')).encode('utf-8')  
			#	except TypeError:
			#		pass

			# Make the filename unique for this ticket
			num = 0
			unique_filename = filename
			dummy_filename, ext = os.path.splitext(filename)

			while (unique_filename in attachment_names) or self.attachment_exists(unique_filename):
				num += 1
				unique_filename = "%s-%s%s" % (dummy_filename, num, ext)
				
			if self.parameters.debug:
				s = 'Attachment with filename %s will be saved as %s' % (filename, unique_filename)
				self.print_unicode(s)

			attachment_names.add(unique_filename)

			renamed_parts.append((filename, unique_filename, part))
	
		return renamed_parts
			
			
	def attachment_exists(self, filename):

		if self.parameters.debug:
			s = 'attachment already exists: Id : %s, Filename : %s' %(self.id, filename)
			self.print_unicode(s)

		# We have no valid ticket id
		#
		if not self.id:
			return False

		try:
			if self.system == 'discussion':
				att = attachment.Attachment(self.env, 'discussion', 'ticket/%s'
				  % (self.id,), filename)
			else:
				att = attachment.Attachment(self.env, 'ticket', self.id,
				  filename)
			return True
		except attachment.ResourceNotFound:
			return False

########## TRAC Ticket Text ###########################################################
			
	def body_text(self, message_parts):
		body_text = []
		
		for part in message_parts:
			# Plain text part, append it
			if not isinstance(part, tuple):
				body_text.extend(part.strip().splitlines())
				body_text.append("")
				continue
				
			(original, filename, part) = part
			inline = self.inline_part(part)
			
			if part.get_content_maintype() == 'image' and inline:
				if self.system != 'discussion':
					body_text.append('[[Image(%s)]]' % filename)
				body_text.append("")
			else:
				if self.system != 'discussion':
					body_text.append('[attachment:"%s"]' % filename)
				body_text.append("")
				
		body_text = '\r\n'.join(body_text)
		return body_text

	def html_mailto_link(self, subject):
		"""
		This function returns a HTML mailto tag with the ticket id and author email address
		"""
		if not self.author:
			author = self.email_addr
		else:	
			author = self.author

		if not self.parameters.mailto_cc:
			self.parameters.mailto_cc = ''

		# use urllib to escape the chars
		#
		s = 'mailto:%s?Subject=%s&Cc=%s' %( 
		       urllib.quote(self.email_addr), 
			   urllib.quote('Re: #%s: %s' %(self.id, subject)),
			   urllib.quote(self.parameters.mailto_cc)
			   )

		s = '\r\n{{{\r\n#!html\r\n<a\r\n href="%s">Reply to: %s\r\n</a>\r\n}}}\r\n' %(s, author)
		return s

########## TRAC notify section ###########################################################

	def notify(self, tkt, new=True, modtime=0):
		"""
		A wrapper for the TRAC notify function. So we can use templates
		"""
		self.logger.debug('function notify()')

		if self.parameters.dry_run:
				print 'DRY_RUN: self.notify(tkt, True) reporter = %s' %tkt['reporter']
				return
		try:

			#from trac.ticket.web_ui import TicketModule
			#from trac.ticket.notification import TicketNotificationSystem
			#ticket_sys = TicketNotificationSystem(self.env)
			#a = TicketModule(self.env)
			#print a.__dict__
			#tn_sys = TicketNotificationSystem(self.env)
			#print tn_sys
			#print tn_sys.__dict__
			#sys.exit(0)

			# create false {abs_}href properties, to trick Notify()
			#
			if not (self.VERSION in [0.11, 0.12]):
				self.env.abs_href = Href(self.get_config('project', 'url'))
				self.env.href = Href(self.get_config('project', 'url'))


			tn = TicketNotifyEmail(self.env)

			if self.parameters.alternate_notify_template:

				if self.VERSION >= 0.11:

					from trac.web.chrome import Chrome

					if  self.parameters.alternate_notify_template_update and not new:
						tn.template_name = self.parameters.alternate_notify_template_update
					else:
						tn.template_name = self.parameters.alternate_notify_template

					tn.template = Chrome(tn.env).load_template(tn.template_name, method='text')
						
				else:

					tn.template_name = self.parameters.alternate_notify_template

			tn.notify(tkt, new, modtime) 

		except Exception, e:
			self.logger.error('Failure sending notification on creation of ticket #%s: %s' %(self.id, e))



########## Parse Config File  ###########################################################

def ReadConfig(file, name):
	"""
	Parse the config file
	"""
	if not os.path.isfile(file):
		print 'File %s does not exist' %file
		sys.exit(1)

	config = trac_config.Configuration(file)

  	# Use given project name else use defaults
  	#
	if name:
		sections = config.sections()
		if not name in sections:
			print "Not a valid project name: %s" %name
			print "Valid names: %s" %sections
			sys.exit(1)

		project =  SaraDict()
		for option, value in  config.options(name):
			try:
				project[option] = int(value)
			except ValueError:
				project[option] = value 

	else:
		# use some trac internals to get the defaults
		#
		tmp = config.parser.defaults()
		project =  SaraDict()

		for option, value in tmp.items():
			try:
				project[option] = int(value)
			except ValueError:
				project[option] = value 

	return project

########## Setup Logging ###############################################################

def setup_log(parameters, project_name, interactive=None):
	"""
	Setup loging

	Note for log format the usage of `$(...)s` instead of `%(...)s` as the latter form
    would be interpreted by the ConfigParser itself.
	"""
	logger = logging.getLogger('email2trac %s' %project_name)

	if interactive:
		parameters.log_type = 'stderr'

	if not parameters.log_type:
		parameters.log_type = 'syslog'

	if parameters.log_type == 'file':

		if not parameters.log_file:
			parameters.log_file = 'email2trac.log'

		if not os.path.isabs(parameters.log_file):
			import tempfile
			parameters.log_file = os.path.join(tempfile.gettempdir(), parameters.log_file)

		log_handler = logging.FileHandler(parameters.log_file)

	elif parameters.log_type in ('winlog', 'eventlog', 'nteventlog'):
		# Requires win32 extensions
		log_handler = logging.handlers.NTEventLogHandler(logid, logtype='Application')

	elif parameters.log_type in ('syslog', 'unix'):
		log_handler = logging.handlers.SysLogHandler('/dev/log')

	elif parameters.log_type in ('stderr'):
		log_handler = logging.StreamHandler(sys.stderr)

	else:
		log_handler = logging.handlers.BufferingHandler(0)

	if parameters.log_format:
		parameters.log_format = parameters.log_format.replace('$(', '%(')
	else:
		parameters.log_format = '%(name)s: %(message)s'

	log_formatter = logging.Formatter(parameters.log_format)
	log_handler.setFormatter(log_formatter) 
	logger.addHandler(log_handler)

	if (parameters.log_level in ['DEBUG', 'ALL']) or (parameters.debug > 0):
		logger.setLevel(logging.DEBUG)

	elif parameters.log_level in ['INFO'] or parameters.verbose:
		logger.setLevel(logging.INFO)

	elif parameters.log_level in ['WARNING']:
		logger.setLevel(logging.WARNING)

	elif parameters.log_level in ['ERROR']:
		logger.setLevel(logging.ERROR)

	elif parameters.log_level in ['CRITICAL']:
		logger.setLevel(logging.CRITICAL)

	else:
		logger.setLevel(logging.INFO)

	return logger


if __name__ == '__main__':
	# Default config file
	#
	configfile = '@email2trac_conf@'
	project = ''
	component = ''
	ticket_prefix = 'default'
	dry_run = None
	verbose = None
	debug_interactive = None

	SHORT_OPT = 'cdhf:np:t:v'
	LONG_OPT  =  ['component=', 'debug', 'dry-run', 'help', 'file=', 'project=', 'ticket_prefix=', 'verbose']

	try:
		opts, args = getopt.getopt(sys.argv[1:], SHORT_OPT, LONG_OPT)
	except getopt.error,detail:
		print __doc__
		print detail
		sys.exit(1)
	
	project_name = None
	for opt,value in opts:
		if opt in [ '-h', '--help']:
			print __doc__
			sys.exit(0)
		elif opt in ['-c', '--component']:
			component = value
		elif opt in ['-d', '--debug']:
			debug_interactive = 1
		elif opt in ['-f', '--file']:
			configfile = value
		elif opt in ['-n', '--dry-run']:
			dry_run = True
		elif opt in ['-p', '--project']:
			project_name = value
		elif opt in ['-t', '--ticket_prefix']:
			ticket_prefix = value
		elif opt in ['-v', '--verbose']:
			verbose = True
	
	settings = ReadConfig(configfile, project_name)

	# The default prefix for ticket values in email2trac.conf
	#
	settings.ticket_prefix = ticket_prefix
	settings.dry_run = dry_run
	settings.verbose = verbose

	if not settings.debug and debug_interactive:
		settings.debug = debug_interactive

	if not settings.project:
		print __doc__
		print 'No Trac project is defined in the email2trac config file.'
		sys.exit(1)

	logger = setup_log(settings, os.path.basename(settings.project), debug_interactive)
	
	if component:
		settings['component'] = component

	# Determine major trac version used to be in email2trac.conf
	# Quick hack for 0.12
	#
	version = '0.%s' %(trac_version.split('.')[1])
	if version.startswith('0.12'):
		version = '0.12'

	logger.debug("Found trac version: %s" %(version))
	
	#debug HvB
	#print settings

	try:
		if version == '0.10':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import util
			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail
			from trac import config as trac_config
			from trac.core import TracError

		elif version == '0.11':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import config as trac_config
			from trac import util
			from trac.core import TracError
			from trac.perm import PermissionSystem

			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail

		elif version == '0.12':
			from trac import attachment 
			from trac.env import Environment
			from trac.ticket import Ticket
			from trac.web.href import Href
			from trac import config as trac_config
			from trac import util
			from trac.core import TracError
			from trac.perm import PermissionSystem

			#
			# return  util.text.to_unicode(str)
			#
			# see http://projects.edgewall.com/trac/changeset/2799
			from trac.ticket.notification import TicketNotifyEmail


		else:
			logger.error('TRAC version %s is not supported' %version)
			sys.exit(1)

		# Must be set before environment is created
		#
		if settings.has_key('python_egg_cache'):
			python_egg_cache = str(settings['python_egg_cache'])
			os.environ['PYTHON_EGG_CACHE'] = python_egg_cache

		if settings.debug > 0:
			logger.debug('Loading environment %s', settings.project)

		env = Environment(settings['project'], create=0)

		tktparser = TicketEmailParser(env, settings, logger, float(version))
		tktparser.parse(sys.stdin)

	# Catch all errors ans log to SYSLOG if we have enabled this
	# else stdout
	#
	except Exception, error:

		etype, evalue, etb = sys.exc_info()
		for e in traceback.format_exception(etype, evalue, etb):
			logger.critical(e)

		if m:
			tktparser.save_email_for_debug(m, True)

		sys.exit(1)
# EOB
